---
title: "数据结构-树剖/Splay/LCT"
author: forgottencsc
date: Oct 10, 2019
geometry: margin=2cm
output: pdf_document
---

## 树剖

### 重链剖分

### 长链剖分

## Splay

### 基本定义

```cpp
int ch[3][N], sz[N], nc;
int *ls = ch[0], *rs = ch[1], *fa = ch[2];
int val[N];

bool isr(int x) { return !fa[x]; }
int id(int x) { return ch[1][fa[x]] == x; }

int gn(int v) {
    int p = ++nc;
    ls[p] = rs[p] = fa[p] = 0;
    sz[p] = 1; val[p] = v;
    //  ...
    return p;
}

void update(int x, ...) {
    //  ...
}

void push_up(int x) {
    sz[x] = sz[ls[x]] + sz[rs[x]] + 1;
    //  ...
}

void push_down(int x) {
    if (ls[x]) update(ls[x], ...);
    if (rs[x]) update(rs[x], ...);
    //  ...
}

void rot(int x) {
    int y = fa[x], z = fa[y], o = id(x), w = ch[!o][x];
    fa[x] = z; if (!isr(x)) ch[id(y)][z] = x;
    ch[o][y] = w; if (w) fa[w] = y;
    ch[!o][x] = y; fa[y] = x;
    push_up(y); push_up(x);
}

void splay(int x) {
    for (int y; !isr(x); rot(x))
        if(!isr(y=fa[x])) rot(id(x)^id(y)?x:y);
}
```

### 序列维护

注：所有不返回值的`find`在调用完后所求节点即为根。

求`rank`可在`find`后直接使用`sz[ls[r]]+1`。

#### 建树

```cpp
int build(const vector<int>& v, int lb, int rb) {
    if (lb == rb) return 0;
    int mid = (lb + rb) >> 1;
    int x = gn(v[mid]);
    ls[x] = build(v, lb, mid); if (ls[x]) fa[ls[x]] = x;
    rs[x] = build(v, mid + 1, rb); if (rs[x]) fa[rs[x]] = x;
    push_up(x);
    return x;
}
```

```cpp
//  Example:
int n; cin >> n;
vector<int> vv(n);
for (int& v : vv) cin >> v;
int r = build(vv, 0, v.size());
```

#### 查找序列第$k$个节点

```cpp
void find_kth(int& r, int k) {
    int x = r;
    while (1) {
        push_down(x); int cnt = sz[ls[x]];
        if (cnt >= k) x = ls[x];
        else if (cnt == k - 1) break;
        else x = rs[x], k -= cnt + 1;
    }
    splay(x); r = x;
}
```

#### 查找区间

返回代表区间$[lb,rb]$的点。

```cpp
int find_range(int& r, int lb, int rb) {
    assert(lb <= rb);
    int n = sz[r], x = r;
    if (lb != 1 && rb != n) {
        find_kth(r, rb + 1); int rp = r;
        find_kth(r, lb - 1); int lp = r;
        if (fa[rp] != lp) rot(rp); x = ls[rs[r]];
    }
    else if (rb != n) find_kth(r, rb + 1), x = ls[r];
    else if (lb != 1) find_kth(r, lb - 1), x = rs[r];
    return x;
}
```

#### 插入元素

在第$k-1$个元素后插入值为$v$的元素。

```cpp
void insert_kth(int& r, int k, int v) {
    int* p = &r, x;
    while (*p) {
        push_down(x = *p); int c = sz[ls[x]] + 1;
        if (k <= c) p = &ls[x]; else p = &rs[x], k -= c;
    }
    int y = *p = gn(v); fa[y] = x; splay(y); r = y;
}
```

#### 删除根节点

```cpp
void erase(int& r) {
    int x = r; push_down(x);
    if (ls[x]) {
        int y = ls[x]; push_down(y);
        while (rs[y]) push_down(y = rs[y]);
        splay(y); r = y;
    }
    if (!fa[x]) {
        r = rs[x]; if (rs[x]) fa[rs[x]] = 0;
    }
    else {
        int w = rs[x], y = fa[x];
        ch[id(x)][y] = w; if (w) fa[w] = y;
        do push_up(y); while (!isr(y = fa[y]));
    }
}
```

注：删除节点后可考虑回收

#### 修改区间

将...中的tag打到区间$[lb,rb]$上

```cpp
void modify_range(int& r, int lb, int rb, ...) {
    int x = find_range(r, lb, rb); update(x, ...);
    while (!isr(x)) push_up(x = fa[x]);
}
```

#### 插入区间

在第$k-1$个元素后插入区间。

```cpp
void insert_range(int& r, const vector<int>& v, int k) {
    int x = build(v, 0, v.size());
    if (!r) r = x;
    else {
        int n = sz[r];
        if (k == 1) find_kth(r, 1), ls[r] = x, push_up(fa[x] = r);
        else if (k == n + 1) find_kth(r, n), rs[r] = x, push_up(fa[x] = r);
        else {
            find_kth(r, k), find_kth(r, k - 1);
            ls[rs[r]] = x, push_up(fa[x] = rs[r]), push_up(r);
        }
    }
}
```

#### 删除区间

删除区间$[lb,rb]$

```cpp
void erase_range(int& r, int lb, int rb) {
    int x = find_range(r, lb, rb);
    if (!isr(x)) {
        ch[id(x)][fa[x]] = 0;
        while (!isr(x)) push_up(x = fa[x]);
    }
    else r = 0;
}
```

### 二叉搜索树扩展

#### 查找第一个键值大于等于v的节点

```cpp
bool find_lwr(int& r, int v) {
    int x = r, y = -1;
    while (x) { if (val[x] >= v) y = x; x = ch[val[x] < v][x]; }
    if (y != -1) { splay(y), r = y; return true; }
    else return false;
}
```

注：差不多就是`multiset<int>::lower_bound`

#### 查找第一个键值大于v的节点

```cpp
void find_upr(int& r, int v) {
    int x = r, y = -1;
    while (x) { if (val[x] > v) y = x; x = ch[val[x] <= v][x]; }
    if (y != -1) { splay(y), r = y; return true; }
    else return false;
}
```

注：差不多就是`multiset<int>::upper_bound`

#### 新建值为v的节点并插入

```cpp
void insert(int& r, int v) {
    int* p = &r, x;
    while (*p) push_down(x = *p), p = &ch[val[x] < v][x];
    int y = *p = gn(v); fa[y] = x; splay(y); r = y;
}
```

### 区间翻转扩展

```cpp
int rev[N];

int gn(int v) {
    rev[p] = 0;
    //  ...
}

inline void update(int x, int v) {
    if (v) {
        swap(ls[x], rs[x]);
        rev[x] ^= 1;
    }
}
```

注：`update`中其他与左右相关的（如左侧最大子段和）也需要swap

```cpp
//  Example: Reverse Range[lb, rb]
modify_range(r, lb, rb, 1);
```
