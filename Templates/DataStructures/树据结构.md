---
title: "数据结构-树剖/Splay/LCT"
author: forgottencsc
date: Oct 9, 2019
geometry: margin=2cm
output: pdf_document
---

## 树剖

### 重链剖分

### 长链剖分

## Splay

### 基本定义

```cpp
int ch[3][N], sz[N], nc;
int *ls = ch[0], *rs = ch[1], *fa = ch[2];
int val[N];

int gn(int v) {
    int p = ++nc;
    ls[p] = rs[p] = fa[p] = 0;
    sz[p] = 1; val[p] = v;
    //  ...
    return p;
}

void push_up(int x) {
    sz[x] = sz[ls[x]] + sz[rs[x]] + 1;
    //  ...
}

void push_down(int x) {
    //  ...
}

void push_tag(int x) {
    static int s[100], t = 0;
    s[++t] = x; while (!isr(x)) s[++t] = (x = fa[x]);
    while (t) push_down(s[t--]);
}

bool isr(int x) { return !fa[x]; }
int id(int x) { return ch[1][fa[x]] == x; }

void rot(int x) {
    int y = fa[x], z = fa[y], o = id(x), w = ch[!o][x];
    fa[x] = z; if (!isr(x)) ch[id(y)][z] = x;
    ch[o][y] = w; if (w) fa[w] = y;
    ch[!o][x] = y; fa[y] = x;
    push_up(y); push_up(x);
}

void splay(int x) {
    for (int y; !isr(x); rot(x))
        if (!isr(y = fa[x])) rot(id(x)^id(y)?x:y);
}
```

### 序列维护

#### 查找序列第$k$个节点

```cpp
void find_kth(int& r, int k) {
    int x = r, y = -1;
    while (y == -1) {
        push_down(x);
        int cnt = sz[ls[x]];
        if (cnt >= k) x = ls[x];
        else if (cnt == k - 1) y = x;
        else x = rs[x], k -= cnt + 1;
    }
    splay(y); r = y;
}
```

#### 查找维护[lb,rb]区间的节点

```cpp
int find_range(int& r, int lb, int rb) {
    int n = sz[r], x = r;
    if (lb != 1 && rb != n) {
        find_kth(r, rb + 1); int rp = r;
        find_kth(r, lb - 1); int lp = r;
        if (fa[rp] != lp) rot(rp); x = ls[rs[r]];
    }
    else if (rb != n) find_kth(r, rb + 1), x = ls[r];
    else if (lb != 1) find_kth(r, lb - 1), x = rs[r];
    return x;
}
```

#### 在第$k$个节点前插入一个节点

```cpp
void ins_kth(int& r, int k, int v) {
    int* p = &r, x;
    while (*p) {
        push_down(x = *p);
        int c = sz[ls[x]] + 1;
        if (k <= c) p = &ls[x];
        else p = &rs[x], k -= c;
    }
    int y = *p = gn(v);
    fa[y] = x; splay(y); r = y;
}
```

#### 删除编号为x的节点

```cpp
void del(int& r, int x) {
    if (ls[x]) {
        int y = ls[x]; while (rs[y]) y = rs[y];
        splay(y); r = y;
    }
    if (!fa[x]) {
        r = rs[x]; if (rs[x]) fa[rs[x]] = 0;
    }
    else {
        ch[id(x)][fa[x]] = rs[x];
        fa[rs[x]] = fa[x];
        int y = rs[x];
        splay(y); r = y;
    }
}
```

### 二叉搜索树扩展

#### 查找第一个键值大于等于v的节点

```cpp
void find_lwr(int& r, int v) {
    int x = r, y = -1;
    while (x) {
        if (val[x] >= v) y = x;
        x = ch[val[x] < v][x];
    }
    if (y != -1) splay(y), r = y;
}
```

#### 查找第一个键值大于v的节点

```cpp
void find_upr(int& r, int v) {
    int x = r, y = -1;
    while (x) {
        if (val[x] > v) y = x;
        x = ch[val[x] <= v][x];
    }
    if (y != -1) splay(y), r = y;
}
```

#### 新建值为v的节点并插入

```cpp
void ins(int& r, int v) {
    int* p = &r, x;
    while (*p) push_down(x = *p), p = &ch[val[x] < v][x];
    int y = *p = gn(v); fa[y] = x;
    splay(y); r = y;
}
```

### 区间翻转扩展

```cpp
int rev[N];

int gn(int v) {
    rev[p] = 0;
    //  ...
}

inline void update(int x) {
    swap(ls[x], rs[x]);
    rev[x] ^= 1;
}

void push_down(int x) {
    if (rev[x]) {
        update(ls[x]);
        update(rs[x]);
        rev[x] = 0;
    }
}
```

```cpp
//  Example: Reverse Range[lb, rb]
update(find_range(r, lb, rb));
```
