#include<bits/stdc++.h>
#include<ext/pb_ds/priority_queue.hpp>
#define fi first
#define se second
using namespace __gnu_pbds;
using namespace std;
typedef long long LL;
typedef pair<int, int> P;

const int maxn = 2e5 + 5;
const int mod = 1e9 + 7;
const LL inf = 1e14 + 5;

template <class T>
inline bool In(T &ret) {
    char c = getchar();
    ret = 0;
    if(c == EOF) return false;
    T flag = 1;
    while (c != '-' && !isdigit(c)) c = getchar();
    if(c == '-') flag = -1, c = getchar();
    while (isdigit(c)) ret = ret * 10 + (c - '0'), c = getchar();
    ret *= flag;
    return true;
}

int p[maxn];
LL val[maxn], lz[maxn];
int ff(int x) {
    if(p[x] != x) {
        int w = ff(p[x]);
        val[x] += lz[p[x]];
        lz[x] += lz[p[x]];
        p[x] = w;
    }
    return p[x];
}

struct node {
    LL w;
    int u, v;
    node(LL _w = 0, int _u = 0, int _v = 0): w(_w), u(_u), v(_v) {};
};
struct cmp {
    bool operator()(node a, node b) {
        ff(a.v), ff(b.v);
        return val[a.v] + a.w > val[b.v] + b.w;
    }
};
__gnu_pbds::priority_queue<node, cmp, pairing_heap_tag> q[maxn];

int vis[maxn], fa[maxn];
node edge[maxn];
vector<int> son[maxn];
stack<int> st;
queue<int> cq;

LL DMST(int rt, int n) {
    int i, m = n, u, v;
    LL ret = 0;
    for(i = 0; i < n; i++) q[i].push(node(inf, (i + 1) % n, i));//额外加无穷大边,使图成为一个强联通
    st.push(0);
    while(true) {
        v = st.top();
        while(!q[v].empty() && ff(q[v].top().u) == v) q[v].pop();
        if(q[v].empty()) break;
        node e = q[v].top();
        ff(e.v);
        edge[v] = e;
        v = ff(e.u);
        if(vis[v]) {
            do {
                u = st.top();
                st.pop();
                fa[u] = p[u] = m;
                son[m].push_back(u);
                lz[u] -= edge[u].w + val[edge[u].v];
                val[u] -= edge[u].w + val[edge[u].v];
                q[m].join(q[u]);
            } while(u != v);
            v = m++;
        }
        st.push(v);
        vis[v] = 1;
    }
    cq.push(rt);
    while(!cq.empty()) {
        u = cq.front();
        cq.pop();
        while(fa[u] != -1) {
            for(auto e : son[fa[u]]) {
                if(e != u) {
                    fa[e] = -1;
                    if(son[e].size()) {
                        edge[edge[e].v] = edge[e];
                        cq.push(edge[e].v);
                    }
                }
            }
            u = fa[u];
        }
    }
    for(i = 0; i < n; i++) {
        if(i != rt) ret += edge[i].w;
    }
    if(ret > inf) ret = -1;
    return ret;
}

void init(int n) {
    n *= 2;
    for(int i = 0; i < n; i++) p[i] = i;
    for(int i = 0; i < n; i++) son[i].clear();
    for(int i = 0; i < n; i++) q[i].clear();
    fill(val, val + n, 0);
    fill(lz, lz + n, 0);
    fill(vis, vis + n, 0);
    fill(fa, fa + n, -1);
    while(!st.empty()) st.pop();
}

int main() {
        int n, m, rt, i, u, v, w;
        In(n), In(m), In(rt);
        init(n);
        rt--;
        for(i = 0; i < m; i++) {
            In(u), In(v), In(w);
            u--, v--;
            q[v].push(node(w, u, v));
        }
        cout << DMST(rt, n) << endl;
    return 0;
}