---
title: "图论-匹配与流"
author: forgottencsc
date: Oct 10, 2019
geometry: margin=1cm
output: pdf_document
---

# 匹配与流

## 增广路

### Hopcroft-Karp

二分图最大匹配

```cpp
vector<int> g[N]; int n1, n2;
int lnk[N], dis[N], dm; bool vis[N];
void clr_hk(int n, int m) {
    n1 = n; n2 = m;
    for (int i = 1; i <= n1 + n2; ++i)
        g[i].clear();
}

bool bfs_hk() {
    queue<int> q; dm = INT_MAX;
    fill(dis + 1, dis + n1 + n2 + 1, -1);
    for (int i = 1; i <= n1; ++i)
        if (!lnk[i]) q.push(i), dis[i] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        if (dis[u] > dm) break;
        for (int v : g[u]) {
            if (dis[v] != -1) continue;
            dis[v] = dis[u] + 1;
            if (!lnk[v]) dm = dis[v];
            else dis[lnk[v]] = dis[v] + 1, q.push(lnk[v]);
        }
    }
    return dm != INT_MAX;
}

int dfs_hk(int u) {
    for (int v : g[u]) {
        if (vis[v] || dis[v] != dis[u] + 1) continue;
        vis[v] = 1;
        if (lnk[v] && dis[v] == dm) continue;
        if (lnk[v] && !dfs_hk(lnk[v])) continue;
        lnk[v] = u; lnk[u] = v; return 1;
    }
    return 0;
}

int hk() {
    fill (lnk + 1, lnk + n1 + n2 + 1, 0);
    int res = 0;
    while (bfs_hk()) {
        fill (vis + 1, vis + n1 + n2 + 1, 0);
        for (int i = 1; i <= n1; ++i)
            if (!lnk[i] && dfs_hk(i)) res++;
    }
    return res;
}
```

### Kuhn-Munkres

二分图最大权匹配

### Dinic

最大流

加点前将nc置零

```cpp
const ll inf = LLONG_MAX;
struct edge { int v, p; ll c, f; };
vector<edge> g[N];
int cur[N], dis[N], nc;

int addv(int cnt) {
    while (cnt--) { int p = ++nc; cur[p] = 0; g[p].resize(0); }
    return nc;
}

void adde(int u, int v, ll c) {
    g[u].push_back({ v, g[v].size(), c, 0 });
    g[v].push_back({ u, g[u].size() - 1, c, c });
}

bool bfs(int s, int t) {
    fill_n(dis + 1, nc, INT_MAX); queue<int> q;
    q.push(s); dis[s] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (edge e : g[u]) {
            if (dis[e.v] != INT_MAX || e.c == e.f) continue;
            dis[e.v] = dis[u] + 1; q.push(e.v);
        }
    }
    return dis[t] != INT_MAX;
}

ll dfs(int u, int t, ll df) {
    if (u == t) return df; ll sf = 0;
    for (int& i = cur[u]; i != g[u].size(); ++i) {
        edge& e = g[u][i]; int v = e.v;
        if (dis[v] != dis[u] + 1 || e.c == e.f) continue;
        ll f = dfs(v, t, min(df, e.c - e.f));
        sf += f; e.f += f; g[v][e.p].f -= f; df -= f;
        if (!df) break;
    }
    return sf;
}

ll dinic(int s, int t, ll f = inf) {
    ll sf = 0;
    while(bfs(s, t)) {
        fill_n(cur + 1, nc, 0);
        ll df = dfs(s, t, f);
        sf += df; f -= df;
    }
    return sf;
}
```

### ISAP

最大流

加点前将nc置零

```cpp
struct edge { int p, v; ll c, f; };
vector<edge> g[N];
int cur[N], dis[N], gap[N], nc;
const ll inf = 1ll<<20;

void fclr() { nc = 0; }

int addn(int cnt = 1) {
    while(cnt--) {
        g[++nc].clear(); dis[nc] = -1;
        cur[nc] = gap[nc] = 0;
    }
    return nc;
}

void adde(int u, int v, ll c) {
    g[u].push_back({ g[v].size(), v, c, 0 });
    g[v].push_back({ g[u].size() - 1, u, 0, 0 });
    //cout << u << ' ' << v << ' ' << c << endl;
}

ll dfs_isap(int s, int t, int u, ll f) {
    if (u == t) return f;
    ll sf = 0;
    for (int& i = cur[u]; i != g[u].size(); ++i) {
        edge& e = g[u][i]; int v = e.v;
        if (e.c <= e.f || dis[u] != dis[v] + 1)
            continue;
        ll df = dfs_isap(s, t, v, min(f, e.c - e.f));
        e.f += df; g[v][e.p].f -= df;
        sf += df; f -= df; if (!f) return sf;
    }
    if (!--gap[dis[u]]) dis[s] = nc;
    gap[++dis[u]]++; cur[u] = 0;
    return sf;
}

ll isap(int s, int t, ll f = inf) {
    ll sf = 0; queue<int> q;
    gap[0] = 1; dis[t] = 0; q.push(t);
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = 0; i != g[u].size(); ++i) {
            edge e = g[u][i]; int v = e.v;
            if (g[v][e.p].c <= g[v][e.p].f || dis[v] != -1)
                continue;
            dis[v] = dis[u] + 1;
            gap[dis[v]]++; q.push(v);
        }
    }
    while(dis[s] < nc) sf += dfs_isap(s, t, s, f);
    return sf;
}
```

### MCMF-SPFA

### MCMF-Dijkstra

```cpp
template< typename flow_t, typename cost_t >
struct PrimalDual {
    const cost_t inf;

    struct edge {
        int v;
        flow_t f;
        cost_t c;
        int p;
        bool isrev;
    };
    vector< vector< edge > > g;
    vector< cost_t > pot, d;
    vector< int > pv, pe;

    PrimalDual(int V) : g(V), inf(numeric_limits< cost_t >::max()) {}

    void add_edge(int u, int v, flow_t f, cost_t c) {
        g[u].push_back({v, f, c, (int) g[v].size(), false});
        g[v].push_back({u, 0, -c, (int) g[u].size() - 1, true});
    }

    pair<flow_t, cost_t> min_cost_flow(int s, int t, flow_t f) {
        int V = (int) g.size();
        cost_t ret = 0; flow_t f0 = 0;
        using Pi = pair< cost_t, int >;
        priority_queue< Pi, vector< Pi >, greater< Pi > > q;
        pot.assign(V, 0); pe.assign(V, -1); pv.assign(V, -1);
        while(f > 0) {
            d.assign(V, inf);
            q.emplace(0, s); d[s] = 0;
            while(!q.empty()) {
                Pi p = q.top(); q.pop();
                cost_t du = p.first; int u = p.second;
                if(d[u] < du) continue;
                for(int i = 0; i < g[u].size(); i++) {
                    edge &e = g[u][i];
                    cost_t dv = du + e.c + pot[u] - pot[e.v];
                    if(e.f > 0 && d[e.v] > dv) {
                        d[e.v] = dv;
                        pv[e.v] = u, pe[e.v] = i;
                        q.emplace(d[e.v], e.v);
                    }
                }
            }
            if(d[t] == inf) return { f0, ret };
            for(int v = 0; v < V; v++) pot[v] += d[v];
            flow_t df = f;
            for(int v = t; v != s; v = pv[v])
                df = min(df, g[pv[v]][pe[v]].f);
            f -= df; f0 += df;
            ret += df * pot[t];
            for(int v = t; v != s; v = pv[v]) {
                edge &e = g[pv[v]][pe[v]];
                e.f -= df;
                g[v][e.p].f += df;
            }
        }
        return { f0, ret };
    }
};
```

### MCMF-zkw

### Edmonds(Blossom)

## 其他

### HLPP

加点前将nc置零

```cpp
typedef long long ll;

const ll inf = LLONG_MAX;
struct edge { int v, p; ll c, f; };
vector<edge> g[N];
int h[N], gap[N], nc; ll ef[N]; bool inq[N];
typedef priority_queue<int, vector<int>, function<bool(int,int)>> pq;

int addv(int cnt) {
    while (cnt--) {
        int p = ++nc; g[p].resize(0);
        ef[p] = h[p] = gap[p] = inq[p] = 0;
    }
    return nc;
}

void adde(int u, int v, ll c) {
    g[u].push_back({ v, g[v].size(), c, 0 });
    g[v].push_back({ u, g[u].size() - 1, c, c });
}

bool bfs(int s, int t) {
    fill_n(h + 1, nc, INT_MAX);
    queue<int> q; q.push(t); h[t] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (edge e : g[u])
            if (e.f && h[e.v] == INT_MAX)
                h[e.v] = h[u] + 1, q.push(e.v);
    }
    return h[s] != INT_MAX;
}

void push(pq& q, int u, bool flg = 0) {
    for (edge& e : g[u]) {
        if (e.c == e.f || (!flg && h[e.v] + 1 != h[u])) continue;
        ll df = min(ef[u], e.c - e.f);
        e.f += df; g[e.v][e.p].f -= df;
        ef[u] -= df; ef[e.v] += df;
        if (!inq[e.v]) q.push(e.v), inq[e.v] = 1;
        if (!ef[u]) break;
    }
}

ll hlpp(int s, int t, ll mf = inf) {
    if (!bfs(s, t)) return 0; h[s] = nc; inq[s] = inq[t] = 1;
    pq q([&](int i1, int i2) { return h[i1] < h[i2]; });
    ef[s] = mf; for (int i = 1; i <= nc; ++i) gap[h[i]]++;
    push(q, s, 1); while (!q.empty()) {
        int u = q.top(); q.pop(); inq[u] = 0;
        push(q, u); if (!ef[u]) continue;
        if (!--gap[h[u]]) for (int i = 1; i <= nc; ++i)
            if (i!=s&&i!=t&&h[u]<h[i])h[i]=max(h[i],nc+1);
        h[u] = 2 * nc;
        for (edge e : g[u]) if (e.c != e.f) h[u] = min(h[u], h[e.v] + 1);
        ++gap[h[u]]; q.push(u); inq[u] = 1;
    }
    return mf - ef[s];
}
```
