# 图论

## 连通性

### 强连通

### 点/边双连通

### 割点和桥

## 染色

### 染色数

$O(n2^n)$

```cpp

#define W 23
#define N 1<<23
typedef bitset<W> bs;
typedef long long ll;
bs g[W];
int w[N]; ll a[N], b[N];

int chromatic_number(int n) {
    fill_n(a, 1 << n, 1); fill_n(b, 1 << n, 1);
    for (int i = 0; i != (1 << n); ++i)
        w[i] = w[i >> 1] + (i & 1);
    for (int i = 0; i != (1 << n); ++i)
        for (int j = 0; j != n; ++j)
            if ((i & (1 << j)) && (g[j] & bs(i)).any())
                a[i] = 0;
    a[0] = 0;
    for (int i = 0; i != n; ++i)
        for (int j = 0; j != (1 << n); ++j)
            if (j & (1 << i)) a[j] += a[j ^ (1 << i)];
    int ans = 0;
    for (int k = 1; !ans; ++k) {
        for (int i = 0; i != (1 << n); ++i) b[i] *= a[i];
        ll s = 0;
        for (int i = 0; i != (1 << n); ++i)
            s += (w[i] & 1) ? -b[i] : b[i];
        if (s) ans = k;
    }
    return ans;
}
```

### 独立集/点覆盖计数

$O(n2^{\frac{n}{2}})$

```cpp
typedef long long ll;
ll f[1 << 20];
ll indset_cnt(int n) {
    int n1 = n / 2, n2 = n - n1;
    fill_n(f, 1 << n1, 0);
    for (int i = 0; i != (1 << n1); ++i) {
        f[i] = 1;
        for (int j = 0; j != n1; ++j)
            if (((1 << j) & i) && (g[j] & bs(i)).any())
                f[i] = 0;
    }
    for (int i = 0; i != n1; ++i)
        for (int j = 0; j != (1 << n1); ++j)
            if (j & (1 << i)) f[j] += f[j ^ (1 << i)];
    ll ans = 0;
    bs msk((1 << n1) - 1);
    for (int i = 0; i != (1 << n2); ++i) {
        bool flg = 0; bs b;
        for (int j = 0; j != n2; ++j) {
            if ((1 << j) & i) {
                if ((g[n1 + j] & (bs(i) << n1)).any()) {
                    flg = 1;
                    break;
                }
                b |= g[n1 + j];
            }
        }
        if (flg) continue;
        ans += f[(~b & msk).to_ulong()];
    }
    return ans;
}
```