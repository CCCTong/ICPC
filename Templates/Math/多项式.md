---
title: "多项式"
author: forgottencsc
date: Oct 01, 2019
geometry: margin=2cm
output: pdf_document
---

## 初等对称多项式

对于变量集$X=\{x_1, x_2, ... , x_m\}$，其上的$n$阶初等对称多项式$\sigma_n$被定义为

$$\sigma_n= \sum_{|S|=n,S\subseteq X}{\prod_{x_i \in S}x_i}$$

特别的，恒有$\sigma_0=1$。

即

$$\sigma_1=x_1+x_2+...+x_n$$

$$\sigma_2=x_1x_2+x_1x_3+...+x_{n-1}x_n$$

$$...$$

$$\sigma_{m}=x_1x_2...x_m$$

向$X$中加入元素$x'$后对$\sigma_k$的影响：

$$\sigma_1'=\sigma_1+x'=\sigma_1+\sigma_0x'$$

$$\sigma_2'=\sigma_2+x_1x'+x_2x'+...+x_mx'=\sigma_2+\sigma_1x'$$

$$...$$

$$\sigma_k'=\sigma_k+\sigma_{k-1}x'$$

从$X$中删去元素$x'$后对$\sigma_k$的影响：

$$\sigma_1'=\sigma_1-\sigma_0'x'$$

$$\sigma_2'=\sigma_2-\sigma_1'x'$$

$$...$$

$$\sigma_k'=\sigma_k-\sigma_{k-1}'x'$$

由定义易得对称多项式的OGF：

$$F(x)=\prod_{x_i \in X}(1+x_ix)$$

若设

$$s_n=\sum_{x \in X}{x^n}$$

则存在恒等式（牛顿公式）：

$$\sigma_k=\frac{(-1)^{k-1}}{k}\sum_{i=0}^{k-1}{(-1)^i\sigma_is_{k-i}}$$

以下如无特别说明请默认$f(x)=\sum_{i=0}^{n-1}a_ix^i,g(x)=\sum_{i=0}^{m-1}b_ix^i$

## 多项式操作

有关的前置声明和预处理

```cpp
inline int add(int a, int b) { int r = a + b; return r < P ? r : r - P; }
inline int sub(int a, int b) { int r = a - b; return r < 0 ? r + P : r; }
inline int mul(ll a, ll b) { ll r = a * b; return r % P; }
inline int inv(int a) { return a == 1 ? a : mul(inv(P % a), P - P / a); }
inline int qpm(int a, int b) {
    int r = 1;
    do if (b & 1) r = mul(r, a);
    while (a = mul(a, a), b >>= 1);
    return r;
}

ll invs[N], f[N], fi[N];
ll binom(ll n, ll k) { return mul(f[n], mul(fi[n - k], fi[k])); }
void ginv() {
    invs[1] = 1; f[0] = fi[0] = 1;
    for (int i = 2; i != N; ++i) invs[i] = mul(invs[P % i], (P - P / i));
    for (int i = 1; i != N; ++i) f[i] = mul(f[i - 1], i);
    for (int i = 1; i != N; ++i) fi[i] = mul(fi[i - 1], invs[i]);
}

vector<int> add(const vector<int>& p1, const vector<int>& p2) {
    int n3 = max(p1.size(), p2.size());
    vector<int> pr = p1; pr.resize(n3, 0);
    for (int i = 0; i != p2.size(); ++i) pr[i] = add(pr[i], p2[i]);
    return pr;
}

vector<int> sub(const vector<int>& p1, const vector<int>& p2) {
    int n3 = max(p1.size(), p2.size());
    vector<int> pr = p1; pr.resize(n3, 0);
    for (int i = 0; i != p2.size(); ++i) pr[i] = sub(pr[i], p2[i]);
    return pr;
}

vector<int> mul(const vector<int>& p1, ll k) {
    int n1 = p1.size(); vector<int> p2(n1);
    for (int i = 0; i != n1; ++i) p2[i] = mul(k, p1[i]);
    return p2;
}
```

OGF，EGF互转（每项除阶乘和乘阶乘）

```cpp
vector<int> egf(const vector<int>& g) {
    vector<int> r(g.size());
    for (int i = 0; i != g.size(); ++i)
        r[i] = mul(g[i], fi[i]);
    return r;
}

vector<int> iegf(const vector<int>& g) {
    vector<int> r(g.size());
    for (int i = 0; i != g.size(); ++i)
        r[i] = mul(g[i], f[i]);
    return r;
}
```

### 快速卷积原理

给定$f(x),g(x)$，计算$h(x)=f(x)g(x)$。

因为一个$n-1$次多项式的系数可以被其在$n$个不同位置上的取值唯一确定（考虑对其在$n$个位置上的取值列一个$n$元线性方程组，其系数矩阵即为范德蒙德矩阵，因范德蒙德行列式不为0当且仅当$x_i$两两不同，所以该方程组有唯一解），所以如果对于一个$n-1$次多项式我们能够快速求出$f(x)$在$n$个不同位置上的取值并根据其反推原多项式的系数，卷积即可快速完成。

### 快速傅里叶变换

快速傅里叶变换可在$O(n \log n)$内从$n-1$次多项式的$n$个系数推出多项式在$n$个不同位置的取值。

设$\omega_n$满足$\omega_n^{n}=1$且$\forall i \in \{ 1, 2, ..., n - 1\}$，$\omega_n^i \neq 1$，我们选取的位置即为$x=\omega_n^{i},i\in\{0,1,...,n-1\}$。

考虑利用单位根$\omega_n$分治对系数序列进行变换，即求出$f(\omega_n^k)，k\in \{0,1,...,n-1\}$，这里设$n=2^w$。

将序列按下标的奇偶分成两份，即

$$f_0(x)=\sum_{i=0}^{\frac n2-1} a_{2i}x^{i}$$

$$f_1(x)=\sum_{i=0}^{\frac n2-1}a_{2i+1}x^i$$

对每份分别进行FFT可得$f_0(\omega_{\frac n2}^{k}),f_1(\omega_{\frac n2}^{k}),k \in \{0,1,...,\frac n2-1\}$。

注：对$f_0$和$f_1$进行FFT时所用的单位根为$\omega_{\frac n2}=\omega_n^{2}$，即分治下去所得结果为$f_0,f_1$在$\omega_n^{2k},k\in\{0,1,...,\frac n2 -1\}$上的取值。

$$f(\omega_n^k)=\sum_{i=0}^{n-1}a_i \omega_n^{ki}=\sum_{i=0}^{\frac n2-1}a_{2i} \omega_n^{2ki}+\sum_{i=0}^{\frac n2-1}a_{2i+1}\omega_n^{2ki+k}$$

$$=\sum_{i=0}^{\frac n2-1}a_{2i} \omega_n^{2ki}+\omega_n^k\sum_{i=0}^{\frac n2-1}a_{2i+1}\omega_n^{2ki}=f_0(\omega_n^{2k})+\omega_n^kf_1(\omega_n^{2k})$$

$$f(\omega_n^{k+\frac n2})=f(-\omega_n^k)=\sum_{i=0}^{n-1}a_i(-\omega_n^{k})^i=\sum_{i=0}^{\frac n2 - 1}a_{2i}(-\omega_n^k)^{2i}+\sum_{i=0}^{\frac n2 - 1} a_{2i+1}(-\omega_n^{k})^{2i+1}$$

$$=\sum_{i=0}^{\frac n2 - 1}a_{2i}\omega_n^{2ki}-\omega_n^k\sum_{i=0}^{\frac n2 - 1}a_{2i+1}\omega_n^{2ki}=f_0(\omega_n^{2k})-\omega_n^{k}f_1(\omega_n^{2k})$$

注：上述过程的$k \in \{0,1,...,\frac n2 -1\}$

于是每层分治可以在$O(n)$复杂度内合并，总复杂度$O(n \log n)$。

### 快速傅里叶逆变换

快速傅里叶逆变换可在$O(n \log n)$内从多项式在$n$个不同位置的取值推出多项式的$n$个系数。

考虑对$f$利用单位根$\omega_n$进行FFT得到$g$，再对$g$利用单位根$\omega_n^{-1}$进行FFT得到$h$，并设$g,h$的系数分别为$\{b_j\},\{c_k\}$

$$b_j=\sum_{i=0}^{n-1}a_i\omega_n^{ij}$$

$$
c_k=\sum_{j=0}^{n-1}b_j\omega_n^{-j}=\sum_{j=0}^{n-1}\left(\sum_{i=0}^{n-1}a_i\omega_n^{ij}\right)\omega_n^{-jk}=\sum_{i=0}^{n-1}a_i\sum_{j=0}^{n-1}\omega_n^{ij}\omega_n^{-jk}
=\sum_{i=0}^{n-1}a_i\sum_{j=0}^{n-1}\omega_n^{(i-k)j}
$$

注意到当$i=k$时有

$$
\sum_{j=0}^{n-1}\omega_n^{(i-k)j}=\sum_{j=0}^{n-1}1^j=n
$$

当$i \neq k$时有

$$
\sum_{j=0}^{n-1}\omega_n^{(i-k)j}=\frac{1-\omega_n^{(i-k)n}}{1-\omega_n^{i-k}}=\frac{1-1}{1-\omega_n^{i-k}}=0
$$

所以$c_k=na_k$

### 快速数论变换

在一般的FFT中，取$\omega_n=\cos \frac {2 \pi}{n}+i \sin \frac {2 \pi}{n}$并在复数域上进行运算即可。在系数较大时会产生精度问题，但使用`long double`可大幅度提升精度与TLE风险。

有时我们面对的问题是模素数意义下的，这时我们可以考虑直接在模素数有限域下解决快速傅里叶变换的问题。对于素数$p=2^k r+1$，模$p$域乘法群为$p-1$次循环群$Z_{p-1}$，且有子群$Z_{2^k}=\{g^{ri}|i \in \{0,1,...,2^k-1\}\}$，其生成元的阶为$2^k$，于是我们可取$\omega_n=g^r$这里$g$为模$p$意义下的原根。因此对于素数$p=2^kr+1$，我们可在模$p$意义下进行长度为$2^k$或其因子的FFT。

```cpp
const int W = 19, S = 1 << W, g = 3;
int fr[W][S], fw[2][S];

void init() {
    for (int s = 1; s != W; ++s)
        for (int i = 0; i != (1 << s); ++i)
            fr[s][i] = (fr[s][i>>1]>>1)|((i&1)<<(s-1));
    fw[0][0] = fw[1][0] = 1;
    fw[0][1] = qpm(g, (P - 1) / (1 << W));
    fw[1][1] = inv(fw[0][1]);
    for (int i = 2; i != (1 << W); ++i) {
        fw[0][i] = mul(fw[0][i - 1], fw[0][1]);
        fw[1][i] = mul(fw[1][i - 1], fw[1][1]);
    }
}

int fs, ft;
void init(int n) {
    for (fs = 1, ft = 0; fs < n; fs <<= 1, ++ft);
}

void ntt(int* p, int t) {
    for (int i=0;i!=fs;++i) if (i<fr[ft][i]) swap(p[i],p[fr[ft][i]]);
    for (int i = 1, s = 0; i != fs; i <<= 1, s++)
        for (int j = 0; j != fs; j += (i << 1))
            for (int k = 0; k != i; ++k) {
                int u=p[j+k],v=mul(fw[t][k<<(W-s-1)],p[i+j+k]);
                p[j+k] = add(u, v), p[i+j+k] = sub(u, v);
            }
    for (int i=0,x=inv(fs);t&&i!=fs;++i) p[i]=mul(p[i],x);
}
```

### 任意模数NTT

9次普通NTT，巨大常数，$O(n \log n)$

碰到了建议重新思考生成函数之外的做法或弃题（认真）。

```cpp

//  大数模乘
//  允许使用__int128时
typedef unsigned long long ull;
ull mul(ull a, ull b, ull p) {
    return ((__int128)a * b) % p;
}

//  不允许使用__int128时
typedef unsigned long long ull;
typedef long double ld;
ull mul(ull a, ull b, ull p) {
    ll res = a * b - p * (ull)((ld)a * (ld)b / (ld)p);
    return res + p * (res < 0) - p * (res >= (ll)p);
}


void ntt(ll* a, int f, ll q) {
    static const ll g = 3;
    for (int i = 0; i != fs; ++i) if (i < fr[i]) swap(a[i], a[fr[i]]);
    for (int i = 1; i != fs; i <<= 1) {
        ll e = (q - 1) / (i << 1), w0 = qpm(g, f == 1 ? e : q - 1 - e, q);
        for (int j = 0; j != fs; j += (i << 1)) {
            ll w = 1;
            for (int k = 0; k != i; k++, w = w * w0 % q) {
                ll u = a[j + k], v = w * a[i + j + k] % q;
                a[j + k] = (u + v) % q; a[i + j + k] = (u - v + q) % q;
            }
        }
    }
    if (f == -1) {
        ll d = inv(fs, q);
        for (ll i = 0; i != fs; ++i)
            a[i] = a[i] * d % q;
    }
}

vector<int> mul(const vector<int>& p1, const vector<int>& p2, int n = 0) {
    ll q[4] = { 469762049, 998244353, 1004535809 }; q[3] = q[0] * q[1];
    int n1 = p1.size(), n2 = p2.size(), n3 = n1 + n2 - 1;
    init(n3 + 1); vector<int> pr(n3);
    for (int j = 0; j != 3; ++j) {
        copy_n(p1.begin(), n1, pa); fill(pa + n1, pa + fs, 0);
        copy_n(p2.begin(), n2, pb); fill(pb + n2, pb + fs, 0);
        ntt(pa, 1, q[j]); ntt(pb, 1, q[j]);
        for (int i = 0; i != fs; ++i) pd[j][i] = pa[i] * pb[i] % q[j];
        ntt(pd[j], -1, q[j]);
    }
    ll i1 = inv(q[1] % q[0], q[0]), i2 = inv(q[0] % q[1], q[1]),
             i3 = inv(q[3] % q[2], q[2]);
    for (int i = 0; i != n3; ++i) {
        ll A = (::mul(pd[0][i] * q[1] % q[3], i1, q[3])
              + ::mul(pd[1][i] * q[0] % q[3], i2, q[3])) % q[3];
        ll k = (((pd[2][i] - A) % q[2] + q[2]) % q[2]) * i3 % q[2];
        pr[i] = M(M(M(k) * M(q[3])) + M(A));
    }
    if (n) pr.resize(n, 0);
    return pr;
}

```

### 卷积

给定$f(x),g(x)$，求$h(x)=f(x)g(x)$。

对$f(x)$与$g(x)$分别进行FFT/NTT，计算逐点乘积后进行逆变换即可。

在$n$小的时候暴力计算可减小常数。

```cpp
int pa[N], pb[N], pc[N], pd[3][N];
vector<int> mul0(const vector<int>& p1, const vector<int>& p2) {
    int n1 = p1.size(), n2 = p2.size(), n3 = n1 + n2 - 1;
    vector<int> p3(n3);
    for (int i = 0; i != n1; ++i)
        for (int j = 0; j != n2; ++j)
            p3[i + j] = add(p3[i + j], mul(p1[i], p2[j]));
    return p3;
}

vector<int> mul(const vector<int>& p1, const vector<int>& p2, int n = 0) {
    int n1 = p1.size(), n2 = p2.size(), n3 = n1 + n2 - 1;
    vector<int> pr(n3);
    if (n3 > 150) {
        init(n3 + 1);
        copy_n(p1.begin(), n1, pa); fill(pa + n1, pa + fs, 0);
        copy_n(p2.begin(), n2, pb); fill(pb + n2, pb + fs, 0);
        ntt(pa, 0); ntt(pb, 0);
        for (int i = 0; i != fs; ++i) pc[i] = mul(pa[i], pb[i]);
        ntt(pc, 1); copy(pc, pc + n3, pr.begin());
    }
    else pr = mul0(p1, p2);
    if (n && pr.size() > n) pr.resize(n, 0);
    return pr;
}
```

### 缩放

给定$f(x)$，求$g(x)=f(kx)$

$$g(x)=f(kx)=\sum_{i=0}^{n-1}{a_ik^ix^i}$$

```cpp
vector<int> scale(const vector<int>& a, ll d) {
    vector<int> b = a;
    for (int i = 0; i != b.size(); ++i)
        b[i] = mul(b[i], qpm(d, i));
    return b;
}
```

### 平移

给定$f(x)$，求$g(x)=f(x+\delta)$。

$$
f(x+\delta)=\sum_{i=0}^{n-1}{a_i\sum_{j=0}^i{\binom ij x^j \delta^{i-j}}}
=\sum_{j=0}^{n-1} x^j \sum_{i=j}^{n-1}{\binom ij a_i \delta^{i-j}}
$$

$$
=\sum_{j=0}^{n-1} x^j \sum_{i=0}^{n-j-1} \binom {n-i-1}{j}a_{n-i-1}\delta^{n-i-j-1}
=\sum_{j=0}^{n-1} x^{n-j-1} \sum_{i=0}^{j} \binom {n-i-1}{n-j-1} a_{n-i-1}\delta^{j-i}
$$

令$c_i=a_{n-i-1}(n-i-1)!$，$d_i=\frac{\delta^i}{i!}$

$$
=\sum_{j=0}^n \frac{x^{n-j}}{(n-j)!}\sum_{i=0}^j \frac{(n-i)!}{(j-i)!}a_{n-i} \delta^{j-i}
=\sum_{j=0}^n\frac{x^{n-j}}{(n-j)!}\sum_{i=0}^j c_i d_{j-i}
$$

将序列c与序列d卷起来再乘以阶乘即可。

时间复杂度$O(n \log n)$，大常数。

```cpp
vector<int> shift(const vector<int>& a, ll d) {
    int n = a.size();
    vector<int> b = a, c(n);
    reverse(b.begin(), b.end());
    for (int i = 0; i != n; ++i) {
        b[i] = mul(b[i], f[n - i - 1]);
        if (!i) c[i] = 1;
        else c[i] = mul(c[i - 1], mul(d, invs[i]));
    }
    vector<int> r = mul(b, c, n);
    reverse(r.begin(), r.end());
    return egf(r);
}
```

### 求导

给定$f(x)$，求$g(x)=f'(x)$。

$$g(x)=\sum_{i=0}^{n-2}(i+1)a_{i+1}x^i$$

时间复杂度$O(n)$。

```cpp
vector<int> deriv(const vector<int>& p1) {
    int n1 = p1.size();
    vector<int> p2(n1 - 1);
    for (int i = 1; i != n1; ++i) p2[i - 1] = mul(i, p1[i]);
    return p2;
}
```

### 积分

给定$f(x)=\sum_{i=0}^{n-1}{a_ix^i}$，求$g(x)=\int_0^x{f(t)}dt$。

$$g(x)=\sum_{i=1}^{n}{\frac{a_{i-1}}{i}x^i}$$

时间复杂度$O(n)$。

```cpp
vector<int> integ(const vector<int>& p1) {
    int n1 = p1.size();
    vector<int> p2(n1 + 1, 0);
    for (int i = 0; i != n1; ++i) p2[i + 1] = mul(p1[i], invs[i + 1]);
    return p2;
}
```

### 牛顿迭代

注：以下涉及到牛顿迭代过程中的$\frac n2$均自动向上取整。

给定多项式$t(g)$，求$g(x)$使得$t(g) \equiv 0 \mod x^n$。

设已求出$h(x)$使得$t(h) \equiv 0 \mod x^\frac n2$。

因为有$t(g) \equiv 0 \mod x^n$，所以有$t(g) \equiv 0 \mod x^\frac n2$，因此$g(x) \equiv h(x) \mod x^\frac n2$。

考虑$t(g)$在$h$处的泰勒展开

$$t(g) \equiv \sum_{k=0}^\infty \frac {t^{(k)}(h)}{k!}(g-h)^k \mod x^n$$

因为$g(x)-h(x) \equiv 0 \mod x^ \frac n2$，所以第二项往后的项全部为0，我们得到

$$
0 \equiv t(g) \equiv t(h)+t'(h)(g-h) \mod x^n
$$

解得

$$
g \equiv h- \frac{t(h)}{t'(h)} \mod x^n
$$

边界：当$n=1$时根据具体情况处理。

涉及到牛顿迭代的多项式算法基本都自带巨大常数，可能$n \log n$跑$n=10^5$都要一秒左右。

### 求逆

前置：卷积

给定$f(x)$，求$g(x)$使得$f(x)g(x) \equiv 1 \mod x^{n}$。

考虑牛顿迭代：设$t(g)=\frac 1g-f$，则迭代方程为

$$
g(x) = h(x)-\frac{\frac{1}{h(x)}-f(x)}{-\frac{1}{h^2(x)}}=2h(x)-h^2(x)f(x) \mod x^n
$$

边界：当$n=1$时直接求常数的乘法逆即可。

时间复杂度$O(n \log n)$，大常数。

```cpp
vector<int> inv(const vector<int>& p1) {
    int n1 = p1.size(), n2 = (n1 + 1) >> 1;
    if (n1 == 1) return { ::inv(p1[0]) };
    vector<int> p2 = inv(vector<int>(p1.begin(), p1.begin() + n2));
    init(n1 << 1);
    copy_n(p1.begin(), n1, pa); fill(pa + n1, pa + fs, 0);
    copy_n(p2.begin(), n2, pb); fill(pb + n2, pb + fs, 0);
    ntt(pa, 0); ntt(pb, 0);
    for (int i = 0; i != fs; ++i)
        pc[i] = mul(sub(2, mul(pa[i], pb[i])), pb[i]);
    ntt(pc, 1);
    vector<int> r(n1);
    copy(pc, pc + n1, r.begin());
    return r;
}
```

### 除法与取模

前置：卷积，求逆

给定$f(x)$与$g(x)$，求$q(x)$与$r(x)$使得$f(x)=q(x)g(x)+r(x)$。

其中$q(x)$为$n-m+1$次多项式，$r(x)$为$m-1$次多项式。

考虑将$f(x)$的系数前后翻转

$$f_R(x)=x^{n-1}f(\frac 1x)=\sum_{i=0}^{n-1}a_ix^{n-i-1}$$

将$\frac 1x$作为参数带入上式并两边乘上$x^{n-1}$可得

$$x^{n-1}f(\frac 1x)=x^{n-m+1}q(\frac 1x) x^{m-1}g(\frac 1x)+x^{n-m+1} x^{m-1} r(\frac 1x)$$

$$f_R(x)=q_R(x)g_R(x)+x^{n-m+1}r_R(x)$$

$$f_R(x)=q_R(x)g_R(x) \mod x^{n-m+1}$$

$$q_R(x)=f_R(x)g_R^{-1}(x) \mod x^{n-m+1}$$

对$g_R$多项式求逆后卷上$f_R(x)$并抛掉多余系数即可得到$q_R(x)$，进一步可求出$r_R(x)$。

时间复杂度$O(n \log n)$，大常数。

```cpp

pair<vector<int>, vector<int>> div(const vector<int>& p1, const vector<int>& p2) {
    int n1 = p1.size(), n2 = p2.size(), n3 = n1 - n2 + 1;
    if (n3 <= 0) return { { 0 }, p1 };
    vector<int> p1r = p1, p2r = p2;
    reverse(p1r.begin(), p1r.end());
    reverse(p2r.begin(), p2r.end());
    p1r.resize(n3, 0); p2r.resize(n3, 0);
    vector<int> p3 = mul(p1r, inv(p2r), n3);
    reverse(p3.begin(), p3.end());
    vector<int> p4 = sub(p1, mul(p2, p3));
    p4.resize(n2 - 1, 0);
    return { p3, p4 };
}
```

注：`first`是$q(x)$，`second`是$r(x)$。

### 开根号

前置：卷积，求逆

给定$f(x)$，求$g(x)$使得$g(x)^2 \equiv f(x) \mod x^{n}$。

考虑牛顿迭代：设$t(g)=g^2-f$，则迭代方程为

$$
g(x)=h(x)-\frac{h^2(x)-f(x)}{2h(x)}=\frac{h^2(x)+f(x)}{2h(x)} \mod x^n
$$

边界：当$n=1$时直接求常数的模意义下二次剩余即可。

时间复杂度$O(n \log n)$，大常数。

```cpp
int msqrt(int n) {
    if (!n) return 0;
    int q = P - 1, s = 0, z = 2;
    //while (~q & 1) q >>= 1, s++;
    q >>= (s = __builtin_ctzll(q));
    if (s == 1) return qpm(n, (P + 1) / 4);
    while(qpm(z, (P - 1) / 2) == 1) ++z;
    int c = qpm(z, q), t = qpm(n, q),
       r = qpm(n, (q + 1) / 2), m = s;
    while(t % P != 1) {
        ll i = 1; while(qpm(t, 1ll << i) != 1) ++i;
        ll b = qpm(c, 1ll << (m - i - 1));
        r = mul(r, b); c = mul(b, b);
        t = mul(t, c); m = i;
    }
    return min(r, P - r);
}

vector<int> sqrt(const vector<int>& p1) {
    int n1 = p1.size(), n2 = (n1 + 1) >> 1;
    if (n1 == 1) return { ::msqrt(p1[0]) };
    vector<int> p2 = sqrt({p1.begin(), p1.begin() + n2});
    vector<int> p3 = mul(p2, 2); p3.resize(n1);
    p3 = inv(p3);
    return mul(add(mul(p2, p2, n1), p1), p3, n1);
}
```

### 对数

前置：卷积，求逆，求导，积分

给定$f(x)$，求$g(x)=\ln f(x)$。

$$g(x)=\ln f(x)=\int_0^{x}\frac{f'(t)}{f(t)}dt$$

时间复杂度$O(n \log n)$，大常数。

```cpp
vector<int> log(const vector<int>& p1) {
    return integ(mul(deriv(p1), inv(p1), p1.size() - 1));
}
```

### 指数

前置：卷积，对数

给定$f(x)$，求$g(x)=\exp f(x) \mod x^n$。其中$f(0)=a_0=0$。

考虑牛顿迭代：设$t(g)=\ln g-f$，则迭代方程为

$$
g(x)=h(x)-\frac{\ln h-x}{\frac{1}{h}}=h(x)(1- \ln h+f) \mod x^n
$$

边界：当$n=1$时返回常数1。

时间复杂度$O(n \log n)$，大常数。

```cpp
vector<int> exp(const vector<int>& p1) {
    if (p1.size() == 1) return { 1 };
    vector<int> p2 = exp({p1.begin(),p1.begin()+(p1.size()+1>>1)});
    p2.resize(p1.size(), 0);
    return mul(p2, add(sub({ 1 }, log(p2)), p1), p1.size());
}
```

### 快速幂

前置：对数，指数

给定$f(x)$，求$g(x)=f(x)^k$。

注意到$g(x)=f(x)^k=\exp \ln f(x)^k=\exp k \ln f(x)$，因此快速幂可在$O(n \log n)$内完成。

若$a_0 \neq 1$，则在取对数前需进行如下特判：

若$a_i, i \in \{0, 1, ..., j - 1\}$均为$0$，则可除以一个$x^j$后将$g$像后移$nj$位。

若进行上一步后仍有$a_0 \neq 1$，则将整个序列除以$a_0$，后将整个序列乘以$a_0^k$。

若$nk$较小则在NTT后直接对点值表示快速幂再逆NTT即可(CF1096G)。

时间复杂度$O(n \log n)$，巨大常数。

```cpp
vector<int> pow(const vector<int>& p1, int k) {
    int n1 = p1.size(), n2 = n1;
    while (n2 && !p1[n1 - n2]) n2--;
    int n3 = max(n1 - 1ll * (n1 - n2) * k, 0ll);
    if (!n2 || !n3) return vector<int>(n1, 0);
    vector<int> p2(p1.begin() + n1 - n2, p1.begin() + n1 - n2 + n3);
    ll c = p2[0]; p2 = mul(exp(mul(log(mul(p2, ::inv(c))), k)), qpm(c, k));
    p2.resize(n1, 0); rotate(p2.begin(), p2.begin() + n3, p2.end());
    return p2;
}
```

### 多点求值

给定$f(x)$，和$x_i, i \in \{1, 2, ..., m\}$，求$f(x_i), i \in \{1,2,...,m\}$

构造多项式$g(x)=\prod_{i=1}^m(x-x_i)$，注意到$g(x_i)=0$，考虑多项式除法

$$f(x_i)=q(x_i)g(x_i)+r(x_i)=r(x_i)$$

对$g$取模后只需对$r$求值即可。

$g_{l,r}=\prod_{i=l}^{r}(x-x_i)$可分治求出，将中间结果保存至线段树上后再进行分治，即将对$f$求其在$x_i,i \in \{l,...,r\}$上的值分治为求$f \mod g_{l,mid-1}$在$x_i,i \in \{l,...,mid-1\}$上的值和求$f \mod g_{mid,r}$在$x_i,i \in \{mid,...,r\}$上的值。因NTT常数巨大，所以在分治到一定程度时直接转秦九韶暴力求值可降低常数。

时间复杂度$O(n \log^2 n)$，巨巨巨大常数。

```cpp
vector<int> est[N];

//  秦九韶暴力
int eval(const vector<int>& p, int x) {
    int r = 0;
    for (int i = (int)p.size() - 1; i >= 0; --i)
        r = add(p[i], mul(r, x));
    return r;
}
//  把g分治过程的中间结果存在线段树上
void eval0(const vector<int>& x, int p, int lb, int rb) {
    if (lb + 1 == rb) est[p] = { sub(0, x[lb]), 1 };
    else {
        int mid = (lb + rb) >> 1;
        eval0(x, p << 1, lb, mid);
        eval0(x, p << 1 | 1, mid, rb);
        est[p] = mul(est[p << 1], est[p << 1 | 1]);
    }
}

void eval1(const vector<int>& r, const vector<int>& x,
            int p, int lb, int rb) {
    vector<int> w = div(r, est[p]).second;
    if (lb + 100 >= rb)
        for (int i = lb; i != rb; ++i)
            est[0][i] = eval(w, x[i]);
    else {
        int mid = (lb + rb) >> 1;
        eval1(w, x, p << 1, lb, mid);
        eval1(w, x, p << 1 | 1, mid, rb);
    }
}

vector<int> eval(const vector<int>& p, const vector<int>& x) {
    eval0(x, 1, 0, x.size());
    est[0].resize(x.size());
    eval1(p, x, 1, 0, x.size());
    return est[0];
}
```

## 多项式应用

具体原理见组合.pdf。

### 第一类斯特林数（行）

前置：平移，卷积。

行的OGF：

$$s_n(x)=xs_{n-1}(x)+ns_{n-1}=(x+n)s_{n-1}(x)=\prod_{i=0}^{n}{(x+i)}$$

时间复杂度$O(n \log n)$。

```cpp
vector<int> stirling1_row0(int l, int r) {
    if (l == r) return { l, 1 };
    else {
        int n = r - l + 1, n1 = n / 2, n2 = n - n1;
        vector<int> a = stirling1_row0(l, l + n1 - 1);
        vector<int> b = shift(a, n1);
        vector<int> res = mul(a, b);
        if (n1 == n2) return res;
        vector<int> tmp(n + 1);
        copy(res.begin(), res.end(), tmp.begin() + 1);
        return add(mul(res, r), tmp);
    }
}

vector<int> stirling1_row(int n) {
    return stirling1_row0(0, n - 1);
}
```

### 第一类斯特林数（列）

前置：快速幂

$$s_m(x)=\frac{\left(-\ln(1-x)\right)^m}{m!}$$

时间复杂度$O(n \log n)$，巨大常数。

```cpp
vector<int> stirling1_col(int n, int m) {
    vector<int> a(n + 1, 0);
    for (int i = 1; i <= n; ++i) a[i] = invs[i];
    return iegf(mul(pow(a, m), fi[m]));
}
```

### 第二类斯特林数（行）

前置：卷积

$$S_n(x)=\sum_{k=0}^{n}{\frac {x^k}{k!}\sum_{i=0}^k{(-1)^{i}\binom ki (k-i)^n}}=\sum_{k=0}^{n}{x^k\left(\sum_{i=0}^{k}{\frac{(-1)^{i}}{i!}\frac{(k-i)^n}{(k-i)!}}\right)}$$

时间复杂度$O(n \log n)$。

```cpp
vector<int> stirling2_row(int n) {
    vector<int> a(n + 1, 0), b(n + 1, 0);
    for (int i = 0; i <= n; ++i)
        a[i] = (i & 1 ? sub(0, fi[i]) : add(0, fi[i]));
    for (int i = 0; i <= n; ++i)
        b[i] = mul(qpm(i, n), fi[i]);
    return mul(a, b, n + 1);
}
```

### 第二类斯特林数（列）

前置：卷积，求逆

OGF:$$S_m(x)=\frac{x}{1-mx}S_{m-1}(x)=\frac{x^m}{\prod_{i=1}^{m}{1-ix}}$$

EGF:$$S_m(x)=\frac{(e^x-1)^m}{m!}$$

时间复杂度$O(n \log^2 n)$，常数不大。

```cpp
vector<int> stirling2_col0(int l, int r) {
    if (l == r) return { 1 };
    if (l + 1 == r) return { 1, sub(0, l) };
    else {
        int mid = (l + r) >> 1;
        return mul(stirling2_col0(l, mid)
                 , stirling2_col0(mid, r));
    }
}

vector<int> stirling2_col(int n, int m) {
    if (n < m) return vector<int>(n + 1, 0);
    vector<int> a = stirling2_col0(1, m + 1);
    a.resize(n - m + 1, 0);
    vector<int> b = inv(a); b.resize(n + 1, 0);
    rotate(b.begin(), b.begin() + n + 1 - m, b.end());
    return b;
}
```

### 贝尔数

前置：指数

```cpp
vector<int> bell(int n) {
    vector<int> a(n, 1);
    return iegf(exp(sub(egf(a), {1})));
}
```

### 伯努利数

附赠小常数等幂求和(51nod 1258)

前置：求逆

```cpp
vector<int> bernoulli(int n) {
    vector<int> a(n + 1, 1);
    a = sub(egf(a), { 1 });
    rotate(a.begin(), a.begin() + 1, a.end());
    a.pop_back();
    return iegf(inv(a));
}

ll epsum(const vector<int>& b, ll n, ll k) {
    ll ans = 0; ll w = (n %= P);
    for (int i = 1; i <= k + 1; ++i) {
        ll t = mul(binom(k + 1, k + 1 - i), b[k + 1 - i]);
        if ((k + 1 - i) & 1) ans = sub(ans, mul(w, t));
        else ans = add(ans, mul(w, t));
        w = mul(w, n);
    }
    return mul(ans, invs[k + 1]);
}
```

### 有标号（连通）二分图数量

```cpp
vector<int> colored_bipartite(int n) {
    vector<int> b1(n), b2(n), c;
    int sqrt2 = msqrt(2);
    for (int i = 0; i != n; ++i) {
        b1[i] = qpm(sqrt2, 1ll * i * i);
        b2[i] = inv(b1[i]);
    }
    b1 = iegf(b1); b2 = egf(b2); c = mul(b2, b2, n);
    for (int i = 0; i != n; ++i) c[i] = mul(c[i], b1[i]);
    return c;
}

vector<int> bipartite(int n) {
    return iegf(sqrt(egf(colored_bipartite(n))));
}

vector<int> connected_bipartite(int n) {
    return iegf(mul(log(egf(colored_bipartite(n))),invs[2]));
}
```

## 线性递推

定义：

$$f_n=\sum_{k=1}^m a_kf_{n-k}$$
