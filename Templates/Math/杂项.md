---
title: "杂项"
author: forgottencsc
date: Sept 24, 2019
geometry: margin=2cm
output: pdf_document
---

# 杂项

## 各种预处理与等幂求和（模意义下）

`invs`：逆元
`f`：阶乘
`fi`：阶乘逆元
`bi`：二项式系数
`be`：伯努利数
`ep`：等幂求和系数

```cpp
ll invs[N], f[N], fi[N];
ll bi[N][N], be[N], ep[N][N];
ll inv(ll x) { return x == 1 ? 1 : M(inv(P % x) * (P - P / x)); }
void ginv() {
    invs[1] = 1; f[0] = fi[0] = 1;
    for (int i = 2; i != N; ++i) invs[i] = M(invs[P % i] * (P - P / i));
    for (int i = 1; i != N; ++i) f[i] = M(f[i - 1] * i);
    for (int i = 1; i != N; ++i) fi[i] = M(fi[i - 1] * invs[i]);
    // Binomial coefficient
    for (int i = 0; i != N; ++i) {
        bi[i][0] = bi[i][i] = 1;
        for (int j = 1; j < i; ++j)
            bi[i][j] = M(bi[i - 1][j - 1] + bi[i - 1][j]);
    }
    be[0] = 1;  //  Bernoulli numbers
    for (int i = 1; i != N; ++i)
        for (int j = 0; j != i; ++j)
            be[i] = M(be[i] - M(bi[i][j] * M(be[j] * invs[i - j + 1])));
    //  Equal Power Sum Coef
    ep[0][0] = ep[0][1] = 1;
    for (int i = 1; i != N; ++i)
        for (int j = 0; j <= i; ++j)
            ep[i][i+1-j]=M(M(j&1?-invs[i+1]:invs[i+1])*M(bi[i + 1][j]*be[j]));
}
```

等幂求和：$S_k(n)=\sum_{i=0}^{n}i^k$

```cpp
ll epsum(ll n, ll k) {
    ll w = 1, r = 0;
    for (int i = 0; i <= k + 1; ++i, w = M(w * n))
        r = M(r + M(w * ep[k][i]));
    return r;
}
```

## 排列，置换，群

### 按字典序遍历所有排列

```cpp
int p[N]; iota(p + 1, p + n + 1, 1);
do {
    //  ...
} while (next_permutation(p + 1, p + n + 1));
// 改成prev_permutation并将p初始化为n~1即可从大到小遍历
```

### Cantor展开

```cpp
//  Cantor expansion when S is huge, 1 based
ll cexp(int* a, int n) {
    static int b[N] = {0};
    fill(b+1,b+n+1,0);
    ll res = 0;
    for (int i = n; i >= 1; --i) {
        ll cnt = 0;
        for (int j=a[i]; j; j-=j&-j) cnt += b[j];
        res = M(res + cnt * f[n-i]);
        for (int j=a[i]; j<=n; j+=j&-j) b[j]++;
    }
    return res + 1;
}

//  Cantor expansion when S is small, 0 based
ll cexp(array<int, S> a) {
    int res = 0;
    for (int i = 0; i != S - 1; ++i)
        for (int j = i + 1; j != S; ++j)
            if (a[i] > a[j]) res += f[S - 1 - i];
    return res;
}

array<int, S> icexp(ll x) {
    array<int, S> res;
    vector<int> v(S); iota(v.begin(), v.end(), 0);
    for (int i = 0; i != S; ++i) {
        int t = f[S - i - 1];
        res[i] = v[x / t];
        v.erase(v.begin() + x / t);
        x %= t;
    }
    return res;
}
```

### 循环分解

### Burnside引理/Polya定理（见组合部分）

## 数值算法，线性代数与高维几何

### 拉格朗日插值

已知$f(x)$为次数不超过$n-1$次的多项式与$y_1=f(x_1),y_2=f(x_2),...,y_n=f(x_n)$的值，则$f(x)$在其他任意位置的值可以在$O(n^2)$内求出。

考虑具有特殊性质的多项式

$$p_k(x)=\prod_{i=1,i!=k}^{n}\frac{x-x_i}{x_k-x_i}$$

易知$p_k(x)$在$x_k$处取值为$1$，在其他$x_i$处取值为$0$。那么我们可以直接构造出与$f(x)$恒等的多项式

$$f(x)=\sum_{k=1}^{n}y_kp_k(x)=\sum_{k=1}^{n}{y_k\prod_{i=1,i!=k}^n{\frac{x-x_i}{x_k-x_i}}}$$

当$x_i=x_{i-1}+1$时到$p_k$的分母分子均可快速求出，此时插值可在$O(n)$内完成。

```cpp

//  Lagrangian Interpolation, P(x[0])==y[0], P(x[1])==y[1], ...
ll lintp(const vector<ll>& y, const vector<ll>& x, ll m) {
    int n = y.size(); ll res = 0;
    for (int i = 0; i != n; ++i) {
        ll t = y[i];
        for (int j = 0; j != n; ++j)
            if (j != i)
                t = M(t * M((P+m-x[j]) * inv(P+x[i]-x[j])));
        res = M(res + t);
    }
    return res;
}

//  Lagrangian Interpolation, P(0)==y[0], P(1)==y[1], ...
ll lp[N], ls[N];
ll lintp(const vector<ll>& y, ll x) {
    int n = y.size(); ll res = 0; lp[0] = x; ls[n - 1] = x - (n - 1);
    for (int i = 1; i != n; ++i) lp[i] = M(lp[i - 1] * (x - i));
    for (int i = n - 2; i >= 0; --i) ls[i] = M(ls[i + 1] * (x - i));
    for (int i = 0; i != n; ++i) {
        ll t = (n - i + 1) & 1 ? P - y[i] : y[i];
        if (i)          t = M(t * M(lp[i - 1] * fi[i]));
        if (i != n - 1) t = M(t * M(ls[i + 1] * fi[n - 1 - i]));
        res = M(res + t);
    }
    return res;
}

```

### 高斯消元，零空间

```cpp

#include <bits/stdc++.h>
#define R(m) (int)(m).size()
#define C(m) (int)((m)[0].size())
const dbl eps = 1e-8;
typedef vector<dbl> vec;
typedef vector<vec> mat;

//  Gaussian Elimination, O(n^3)
int row_reduction(mat& a) {
    const int& n = R(a), m = C(a);
    for (int i = 0, j = 0; i != n; ++i) {
        do for (int k = i + 1; k != n; ++k)
            if (fabs(a[i][j]) < fabs(a[k][j]))
                swap(a[i], a[k]);
        while (!dc(a[i][j]) && ++j != n);
        if (j == n) return i; //  rk(a)
        for (int l = m - 1; l >= i; --l)
            a[i][l] /= a[i][j];
        for (int k = 0; k != n; ++k) {
            if (k != i) for (int l = m - 1; l >= i; --l)
                a[k][l] -= a[k][j] * a[i][l];
    }
    return n;
}

//  Get a base of null space of a, O(n^2)
mat nsp(mat& a) {
    const int n = C(a);
    while(R(a) < n) a.push_back(vec(n, 0));
    int w = row_reduction(a); mat b(n, vec(n - w, 0));
    vector<int> p, vis(n, 0);
    for (int c = 0, r = 0; c != n; ++c)
        if (abs(a[r][c]) > eps) ++r, vis[c] = 1;
    for (int i = 0; i != n; ++i) if (vis[i]) p.push_back(i);
    for (int i = 0; i != n; ++i) if (!vis[i]) p.push_back(i);
    for (int i = 0; i != n - w; ++i) {
        for (int j = 0; j != n; ++j)
            b[j][i] = a[p[j]][p[i + w]];
        b[p[i + w]][i] = -1;
    }
    return b;
}
```

### Graham-Schmidt正交化，QR分解

```cpp
//  Gram–Schmidt Orthogonalization, O(n^3)
void gso(mat& a) {
    const int& n = R(a), m = C(a);
    for (int i = 0; i != n; ++i) {
        for (int j = 0; j != i; ++j) {
            dbl l = 0;
            for (int k = 0; k != m; ++k) l += a[i][k] * a[j][k];
            for (int k = 0; k != m; ++k) a[i][k] -= a[j][k] * l;
        }
        dbl l = 0;
        for (int k = 0; k != m; ++k) l += a[i][k] * a[i][k];
        l = sqrt(l);
        for (int k = 0; k != m; ++k) a[i][k] /= l;
    }
}

pair<mat, mat> QR(const mat& a) {
    mat q = a; gso(q);
    return { q, transpose(q) * a };
}

vector<dbl> eigenvalues(mat a) {
    pair<mat, mat> qr;
    for (int i = 0; i != 10; ++i) {
        qr = QR(a);
        a = qr.second * qr.first;
    }
    vector<dbl> res;
    for (int i = 0; i != R(a); ++i)
        res.push_back(a[i][i]);
    return res;
}
```

### 实数的分数逼近(Farey序列与Stern-Brocott树(*))

定义：Farey序列

最开始左侧为$\frac{0}{1}$，右侧为$\frac{1}{0}$

之后向序列中每对相邻的分数$\frac{p_1}{q_1}$与$\frac{p_2}{q_2}$之间插入$\frac{p_1+p_2}{q_1+q_2}$

以$\frac{1}{1}$为根，将除了$\frac{0}{1}$与$\frac{1}{0}$之外的所有分数向生成它的两个分数之中最深的那一个连边即可获得Stern-Brocott树。这里的深是指迭代法雷序列的迭代深度。

若在每次迭代中将所有分母大于当前迭代次数的分数都去掉，则每层新产生的分数为所有分母为当前迭代层数的真分数。

```cpp
pair<ll, ll> get_frac(dbl x, ll p1, ll q1, ll p2, ll q2) {
    ll p3 = (p1 + p2), q3 = (q1 + q2), d = gcd(p3, q3);
    p3 /= d; q3 /= d;
    if (fabs(q3 * x - p3) < eps) return { p3, q3 };
    else if (x * q3 < p3) return get_frac(x, p1, q1, p3, q3);
    else return get_frac(x, p3, q3, p2, q2);
}
```

### 单峰函数求极值

```cpp

typedef double dbl;
const dbl eps = 1e-8, phi = (sqrt(5) - 1) / 2;
pair<dbl, dbl> gss0(const function<dbl(dbl)>& f,
         dbl l1, dbl l2, dbl r2, dbl r1,
         dbl l1v, dbl l2v, dbl r2v, dbl r1v) {
    if (l2 + eps >= r2) {
        if (l2v < r2v) return { l2, l2v };
        else return { r2, r2v };
    }
    if (l2v > r2v)  //  < for minimum, > for maximum
        return gss0(f, l1, r2 - phi * (r2 - l1), l2, r2,
                    l1v, f(r2 - phi * (r2 - l1)), l2v, r2v);
    else
        return gss0(f, l2, r2, l2 + phi * (r1 - l2), r1,
                    l2v, r2v, f(l2 + phi * (r1 - l2)), r1v);
}

pair<dbl, dbl> gss(const function<dbl(dbl)>& f,
                   dbl l1, dbl r1) {
    dbl t = phi * (r1 - l1), l2 = r1 - t, r2 = l1 + t;
    return gss0(f, l1, l2, r2, r1, f(l1), f(l2), f(r2), f(r1));
}

//Example:
//Gym101981D(2018南京现场赛D) 最小球覆盖，三分套三分套三分，nlogM^3
//这里的M是1e5/1e-8=1e13，至少有个1.5倍的常数，因为log的底数是phi+1
int main() {
    cout << fixed << setprecision(10) << gss([&](dbl x) {
            return gss([&](dbl y) {
                return gss([&](dbl z) {
                    dbl res = 0;
                    for (vec w : v)
                        res = max(res, dis(w, {x,y,z}));
                    return res;
                }, -1e5, 1e5).second;
            }, -1e5, 1e5).second;
        }, -1e5, 1e5).second <<endl;
    }
```

### 自适应辛普森积分

```cpp

template<class F> dbl sps0(const F& f,dbl l, dbl r) {
    return (f(l) + 4 * f((l + r) / 2) + f(r)) * (r - l) / 6;
}

template<class F> dbl sps1(const F& f, dbl l, dbl r, dbl eps, dbl s) {
    dbl m = (l + r) / 2, lv = sps0(f, l, m), rv = sps0(f, m, r), d = lv + rv - s;
    if (fabs(d) < 15 * eps) return lv + rv + 15 * d;
    else return sps1(f, l, m, eps / 2, lv) + sps1(f, m, r, eps / 2, rv);
}

template<class F> dbl spsint(const F& f, dbl l, dbl r, dbl eps) {
    return sps1(f, l, r, eps, sps0(f, l, r));
}

```

### 三次/四次方程求复根

```cpp

#define sq(x) ((x) * (x))

#define cb(x) (sq(x) * (x))

typedef complex<dbl> cplx;
void cubic(dbl a0, dbl a1, dbl a2, dbl a3,
    cplx& x1, cplx& x2, cplx& x3) {
    a0 /= a3; a1 /= a3; a2 /= a3;
    dbl p = sq(a2) / 9 - a1 / 3, q = a2 * a1 / 6 - cb(a2) / 27 - a0/ 2;
    cplx del = sqrt((cplx)(sq(q) - cb(p))), w(-0.5, sqrt(3) / 2),
        f1 = pow(q + del, 1. / 3), f2 = pow(q - del, 1. / 3);
    x1 = f1 + f2 - a2 / 3;
    x2 = w * f1 + sq(w) * f2 - a2 / 3;
    x3 = sq(w) * f1 + w * f2 - a2 / 3;
}

void quadr(dbl a0, dbl a1, dbl a2, dbl a3, dbl a4,
    cplx& x1, cplx& x2, cplx& x3, cplx& x4) {
    a0 /= a4; a1 /= a4; a2 /= a4; a3 /= a4; a3 /= 4;
    dbl b = a2 - 6 * sq(a3), c = 3 * (a1 - 2 * a2 * a3 + cb(2 * a3)),
        d = 12 * (a0 - a1 * a3 + a2 * sq(a3) - 3 * sq(sq(a3))),
        p = sq(b) + d, q = 2 * cb(b) + 3 * sq(c) - 6 * b * d, k = 2 * sqrt(3);
    cplx del = sqrt((cplx(sq(q) - 4 * cb(p)))),
        f = pow((q + del) / 2., 1. / 3) + pow((q - del) / 2., 1. / 3),
        f1 = sqrt(f - 2 * b), f2 = k * c / f1, f3 = -4 * b - f;
    x1 = (f1 - sqrt(f3 - f2)) / k - a3; x2 = (f1 + sqrt(f3 - f2)) / k - a3;
    x3 = (-f1 - sqrt(f3 + f2)) / k - a3; x4 = (-f1 + sqrt(f3 + f2)) / k - a3;
}

```

### 多项式方程求实根

```cpp

const dbl eps = 1e-8;
int sgn(dbl d) { return d < -eps ? -1 : d > eps ? 1 : 0; }

dbl val(const vector<dbl>& p, dbl x) {
    dbl w = 1, r = 0;
    for(int i = 0; i != p.size(); ++i, w *= x)
        r += p[i] * w;
    return r;
}

dbl fr(const vector<dbl>& p, dbl lb, dbl ub, bool flg) {
    dbl x = (lb + ub) / 2;
    while(sgn(ub - lb)) {
        dbl res = val(p, x);
        if (!sgn(res)) break;
        else if (flg ^ (sgn(res) == 1)) lb = x;
        else ub = x; x = (ub + lb) / 2;
    }
    return x;
}

vector<dbl> peq(vector<dbl> p) {
    if (p.size() < 2) return {};
    else if (p.size() == 2) return { -p[0] / p[1] };
    else {
        vector<dbl> p_, res, sx, sy; dbl b = 0;
        for (int i = 0; i != p.size(); ++i) b = max(b, abs(p[i] / p[0]) + 1);
        for (int i = 1; i != p.size(); ++i) p_.push_back(p[i] * i);
        sx = peq(p_); sx.insert(sx.begin(), -b); sx.push_back(b);
        for (dbl x : sx) sy.push_back(val(p, x));
        for (int i = 0; i != sx.size() - 1; ++i)
            if (sgn(sy[i] * sy[i + 1]) == -1)
                res.push_back(fr(p, sx[i], sx[i + 1], sgn(sy[i]) == -1));
        return res;
    }
}

```

### 线性规划与对偶

#### 互补松弛定理

#### 单纯形法

```cpp
//  Simple simplex method, maximize cTx, s.t.Ax<=B;
int n, m, c[5001]; dbl a[4001][201], x[201], z;

int dcmp(dbl d) { return d < -eps ? -1 : d <= eps ? 0 : 1; }

void pivot(int u, int v) {
    swap(c[n + u], c[v]);
    dbl k = a[u][v]; a[u][v] = 1;
    for (int j = 0; j <= n; ++j) a[u][j] /= k;
    for (int i = 0; i <= m; ++i) {
        if (i == u || !dcmp(a[i][v])) continue;
        k = a[i][v]; a[i][v] = 0;
        for (int j = 0; j <= n; ++j)
            a[i][j] -= a[u][j] * k;
    }
}

bool init() {
    for (int i = 1; i <= n; ++i) c[i] = i;
    while (1) {
        int u = 0, v = 0;
        for (int i = 1; i <= m; ++i)
            if (dcmp(a[i][0]) == -1 && (!u || dcmp(a[u][0] - a[i][0]) == 1)) u = i;
        if (!u) return 1;
        for (int j = 1; j <= n && !v; ++j)
            if (dcmp(a[u][j]) == -1) v = j;
        if (!v) return 0;
        pivot(u, v);
    }
}

int simplex() {
    if (!init()) return 0;
    while (1) {
        int u = 0, v = 0;
        for (int j = 1; j <= n; ++j)
            if (dcmp(a[0][j]) == 1 && (!v || a[0][j] > a[0][v])) v = j;

        if (!v) {
            z = -a[0][0];
            for (int i = 1; i <= m; ++i)
                x[c[n + i]] = a[i][0];
            return 1;
        }

        dbl w = 1e20;
        for (int i = 1; i <= m; ++i)
            if (dcmp(a[i][v]) == 1 &&
                dcmp(w - a[i][0] / a[i][v]) == 1) {
                w = a[i][0] / a[i][v];
                u = i;
            }
        if (!u) return 2;
        pivot(u, v);
    }
}

```

#### 单纯形法 II

```cpp

int dcmp(const dbl &x) { return x < -eps ? -1 : x > eps; }
struct simplex_t {

    struct cstr_t {
        vector<pair<int, dbl>> a;
        dbl b; int t, r;
    };

    vector<cstr_t> cstrs;
    int m, n; vector<int> c;
    vector<vector<dbl>> a;
    vector<dbl> x;

    // -1 for coeff, 0 for less, 1 for equal, 2 for greater
    void add_cstr(const vector<pair<int, dbl>>& a, dbl b, int t) {
        cstrs.push_back({ a, b, t });
    }

    void pivot(int u, int v) {
        swap(c[n + u], c[v]);
        dbl k = a[u][v]; a[u][v] = 1;
        for (int j = 0; j <= n; ++j) a[u][j] /= k;
        for (int i = 0; i <= m; ++i) {
            if (i == u || !dcmp(a[i][v])) continue;
            k = -a[i][v]; a[i][v] = 0;
            for (int j = 0; j <= n; ++j)
                a[i][j] += a[u][j] * k;
        }
    }

    bool simplex0() {
        while (1) {
            int u = 0, v = 0;
            for (int j = 1; !v && j <= n; ++j)
                if (dcmp(a[0][j]) == 1) v = j;
            if (!v)
                return true;
            dbl w = 1e100;
            for (int i = 1; i <= m; ++i)
                if (dcmp(a[i][v]) == 1 &&
                    dcmp(w - a[i][0] / a[i][v]) == 1) {
                    w = a[i][0] / a[i][v];
                    u = i;
                }
            if (!u)
                return false;
            pivot(u, v);
        }
    }

    //  0 for Infeasible, 2 for Unbounded
    int simplex() {
        int r = 0;
        m = cstrs.size() - 1; n = 0;
        for (cstr_t& cstr : cstrs) {
            for (const pair<int, dbl>& p : cstr.a)
                n = max(n, p.first);
            if (cstr.t == 0 || cstr.t == 2)
                cstr.r = ++r;
            if (cstr.t == -1)
                swap(cstr, cstrs.front());
        }

        c.resize(1 + n + r + m, 0);
        a.resize(m + 1, vector<dbl>(n + r + 1, 0));
        x.resize(1 + n + r, 0);

        for (const pair<int, dbl>& p : cstrs[0].a)
            a[0][p.first] = p.second;
        for (int i = 1; i <= m; ++i) {
            const cstr_t& cstr = cstrs[i];
            for (const pair<int, dbl>& p : cstr.a)
                a[i][p.first] = p.second;
            if (cstr.t == 0) a[i][cstr.r + n] = 1;
            if (cstr.t == 2) a[i][cstr.r + n] = -1;
            a[i][0] = cstr.b;
        }

        n += r;

        for (int i = 1; i <= n + m; ++i) c[i] = i;

        vector<dbl> a0(n + 1, 0); swap(a0, a[0]);
        for (int i = 1; i <= m; ++i) {
            if (a[i][0] < 0)
                for (int j = 0; j <= n; ++j)
                    a[i][j] = -a[i][j];
            for (int j = 0; j <= n; ++j)
                a[0][j] += a[i][j];
        }

        simplex0();

        if (dcmp(a[0][0])) return 0;

        vector<int> cv(1, 0), rv(1, 0);
        for (int i = 1; i <= m; ++i) {
            bool del = 0;
            if (c[n + i] > n) {
                int p = i, q = 0;
                for (int j = 1; !q && j <= n; ++j)
                    if (dcmp(a[i][j]) && c[j] <= n) q = j;
                if (!q) del = 1;
                else pivot(p, q);
            }
            if (!del) rv.push_back(i);
        }
        for (int j = 1; j <= n + m; ++j)
            if (c[j] <= n) cv.push_back(j);

        m = rv.size() - 1; n = n - m;
        vector<vector<dbl>> a1(m + 1, vector<dbl>(n + 1, 0));

        for (int j = 1; j <= n; ++j) a1[0][j] = a0[c[cv[j]]];
        for (int i = 1; i <= m; ++i)
            for (int j = 0; j <= n; ++j)
                a1[i][j] = a[rv[i]][cv[j]];

        for (int i = 1; i <= m; ++i)
            for (int j = 0; j <= n; ++j)
                a1[0][j] -= a0[c[cv[n + i]]] * a1[i][j];

        for (int i = 1; i <= m + n; ++i) cv[i] = c[cv[i]];
        swap(c, cv);
        swap(a, a1);

        if (!simplex0()) return 2;

        x[0] = -a[0][0];
        for (int i = 1; i <= m; ++i)
            x[c[n + i]] = a[i][0];

        return 1;
    }

};

```

### 求两条高维直线的距离

由拉格朗日乘子法易得。

```cpp
typedef double dbl;
const dbl eps = 1e-8;
int sgn(dbl x) { return x < -eps ? -1 : x > eps; }

dbl dis(const vector<dbl>& p, const vector<dbl>& v,
        const vector<dbl>& q) {
    int n = p.size();
    dbl d1 = 0, d = 0;
    for (int i = 0; i != n; ++i) {
        d += v[i] * v[i];
        d1 += v[i] * (p[i] - q[i]);
    }
    dbl t = -d1 / d;
    dbl res = 0;
    for (int i = 0; i != n; ++i)
        res = hypot(res, v[i] * t + p[i] - q[i]);
    return res;
}

dbl dis(const vector<dbl>& p1, const vector<dbl>& v1,
        const vector<dbl>& p2, const vector<dbl>& v2) {
    int n = p1.size();
    dbl a1 = 0, b1 = 0, c1 = 0,
        a2 = 0, b2 = 0, c2 = 0;
    for (int i = 0; i != n; ++i) {
        a1 += v1[i] * v1[i];
        b1 -= v1[i] * v2[i];
        c1 += v1[i] * (p1[i] - p2[i]);
        a2 -= v1[i] * v2[i];
        b2 += v2[i] * v2[i];
        c2 -= v2[i] * (p1[i] - p2[i]);
    }
    dbl d1 = c1 * b2 - c2 * b1,
        d2 = a1 * c2 - a2 * c1,
        d = a1 * b2 - a2 * b1;
    if (!sgn(d)) return dis(p1, v1, p2);
    dbl t1 = - d1 / d, t2 = - d2 / d;
    dbl res = 0;
    for (int i = 0; i != n; ++i)
        res = hypot(res, p1[i] - p2[i] + t1 * v1[i] - t2 * v2[i]);
    return res;
}
```

## 多项式

### 初等对称多项式

对于变量集$X=\{x_1, x_2, ... , x_m\}$，其上的$n$阶初等对称多项式$\sigma_n$被定义为

$$\sigma_n= \sum_{|S|=n,S\subseteq X}{\prod_{x_i \in S}x_i}$$

特别的，恒有$\sigma_0=1$。

即

$$\sigma_1=x_1+x_2+...+x_n$$

$$\sigma_2=x_1x_2+x_1x_3+...+x_{n-1}x_n$$

$$...$$

$$\sigma_{m}=x_1x_2...x_m$$

向$X$中加入元素$x'$后对$\sigma_k$的影响：

$$\sigma_1'=\sigma_1+x'=\sigma_1+\sigma_0x'$$

$$\sigma_2'=\sigma_2+x_1x'+x_2x'+...+x_mx'=\sigma_2+\sigma_1x'$$

$$...$$

$$\sigma_k'=\sigma_k+\sigma_{k-1}x'$$

从$X$中删去元素$x'$后对$\sigma_k$的影响：

$$\sigma_1'=\sigma_1-\sigma_0'x'$$

$$\sigma_2'=\sigma_2-\sigma_1'x'$$

$$...$$

$$\sigma_k'=\sigma_k-\sigma_{k-1}'x'$$

由定义易得对称多项式的OGF：

$$F(x)=\prod_{x_i \in X}(1+x_ix)$$

若设

$$s_n=\sum_{x \in X}{x^n}$$

则存在恒等式（牛顿公式）：

$$\sigma_k=\frac{(-1)^{k-1}}{k}\sum_{i=0}^{k-1}{(-1)^i\sigma_is_{k-i}}$$

以下如无特别说明请默认$f(x)=\sum_{i=0}^{n-1}a_ix^i,g(x)=\sum_{i=0}^{m-1}b_ix^i$

### 多项式操作

有关的前置声明和预处理

```cpp
inline int add(int a, int b) { int r = a + b; return r < P ? r : r - P; }
inline int sub(int a, int b) { int r = a - b; return r < 0 ? r + P : r; }
inline int mul(ll a, ll b) { ll r = a * b; return r % P; }
inline int inv(int a) { return a == 1 ? a : mul(inv(P % a), P - P / a); }
inline int qpm(int a, int b) {
    int r = 1;
    do if (b & 1) r = mul(r, a);
    while (a = mul(a, a), b >>= 1);
    return r;
}

ll invs[N], f[N], fi[N];
ll binom(ll n, ll k) { return mul(f[n], mul(fi[n - k], fi[k])); }
void ginv() {
    invs[1] = 1; f[0] = fi[0] = 1;
    for (int i = 2; i != N; ++i) invs[i] = mul(invs[P % i], (P - P / i));
    for (int i = 1; i != N; ++i) f[i] = mul(f[i - 1], i);
    for (int i = 1; i != N; ++i) fi[i] = mul(fi[i - 1], invs[i]);
}

vector<int> add(const vector<int>& p1, const vector<int>& p2) {
    int n3 = max(p1.size(), p2.size());
    vector<int> pr = p1; pr.resize(n3, 0);
    for (int i = 0; i != p2.size(); ++i) pr[i] = add(pr[i], p2[i]);
    return pr;
}

vector<int> sub(const vector<int>& p1, const vector<int>& p2) {
    int n3 = max(p1.size(), p2.size());
    vector<int> pr = p1; pr.resize(n3, 0);
    for (int i = 0; i != p2.size(); ++i) pr[i] = sub(pr[i], p2[i]);
    return pr;
}

vector<int> mul(const vector<int>& p1, ll k) {
    int n1 = p1.size(); vector<int> p2(n1);
    for (int i = 0; i != n1; ++i) p2[i] = mul(k, p1[i]);
    return p2;
}

vector<int> egf(const vector<int>& g) {
    vector<int> r(g.size());
    for (int i = 0; i != g.size(); ++i)
        r[i] = mul(g[i], fi[i]);
    return r;
}

vector<int> iegf(const vector<int>& g) {
    vector<int> r(g.size());
    for (int i = 0; i != g.size(); ++i)
        r[i] = mul(g[i], f[i]);
    return r;
}
```

#### 卷积——引入

给定$f(x),g(x)$，计算$h(x)=f(x)g(x)$。

因为一个$n-1$次多项式的系数可以被其在$n$个不同位置上的取值唯一确定（考虑对其在$n$个位置上的取值列一个$n$元线性方程组，其系数矩阵即为范德蒙德矩阵，因范德蒙德行列式不为0当且仅当$x_i$两两不同，所以该方程组有唯一解），所以如果对于一个$n-1$次多项式我们能够快速求出$f(x)$在$n$个不同位置上的取值并根据其反推原多项式的系数，卷积即可快速完成。

#### 快速傅里叶变换

快速傅里叶变换可在$O(n \log n)$内从$n-1$次多项式的$n$个系数推出多项式在$n$个不同位置的取值。

设$\omega_n$满足$\omega_n^{n}=1$且$\forall i \in \{ 1, 2, ..., n - 1\}$，$\omega_n^i \neq 1$，我们选取的位置即为$x=\omega_n^{i},i\in\{0,1,...,n-1\}$。

考虑利用单位根$\omega_n$分治对系数序列进行变换，即求出$f(\omega_n^k)，k\in \{0,1,...,n-1\}$，这里设$n=2^w$。

将序列按下标的奇偶分成两份，即

$$f_0(x)=\sum_{i=0}^{\frac n2-1} a_{2i}x^{i}$$

$$f_1(x)=\sum_{i=0}^{\frac n2-1}a_{2i+1}x^i$$

对每份分别进行FFT可得$f_0(\omega_{\frac n2}^{k}),f_1(\omega_{\frac n2}^{k}),k \in \{0,1,...,\frac n2-1\}$。

注：对$f_0$和$f_1$进行FFT时所用的单位根为$\omega_{\frac n2}=\omega_n^{2}$，即分治下去所得结果为$f_0,f_1$在$\omega_n^{2k},k\in\{0,1,...,\frac n2 -1\}$上的取值。

$$f(\omega_n^k)=\sum_{i=0}^{n-1}a_i \omega_n^{ki}=\sum_{i=0}^{\frac n2-1}a_{2i} \omega_n^{2ki}+\sum_{i=0}^{\frac n2-1}a_{2i+1}\omega_n^{2ki+k}$$

$$=\sum_{i=0}^{\frac n2-1}a_{2i} \omega_n^{2ki}+\omega_n^k\sum_{i=0}^{\frac n2-1}a_{2i+1}\omega_n^{2ki}=f_0(\omega_n^{2k})+\omega_n^kf_1(\omega_n^{2k})$$

$$f(\omega_n^{k+\frac n2})=f(-\omega_n^k)=\sum_{i=0}^{n-1}a_i(-\omega_n^{k})^i=\sum_{i=0}^{\frac n2 - 1}a_{2i}(-\omega_n^k)^{2i}+\sum_{i=0}^{\frac n2 - 1} a_{2i+1}(-\omega_n^{k})^{2i+1}$$

$$=\sum_{i=0}^{\frac n2 - 1}a_{2i}\omega_n^{2ki}-\omega_n^k\sum_{i=0}^{\frac n2 - 1}a_{2i+1}\omega_n^{2ki}=f_0(\omega_n^{2k})-\omega_n^{k}f_1(\omega_n^{2k})$$

注：上述过程的$k \in \{0,1,...,\frac n2 -1\}$

于是每层分治可以在$O(n)$复杂度内合并，总复杂度$O(n \log n)$。

#### 快速傅里叶逆变换

快速傅里叶逆变换可在$O(n \log n)$内从多项式在$n$个不同位置的取值推出多项式的$n$个系数。

考虑对$f$利用单位根$\omega_n$进行FFT得到$g$，再对$g$利用单位根$\omega_n^{-1}$进行FFT得到$h$，并设$g,h$的系数分别为$\{b_j\},\{c_k\}$

$$b_j=\sum_{i=0}^{n-1}a_i\omega_n^{ij}$$

$$
c_k=\sum_{j=0}^{n-1}b_j\omega_n^{-j}=\sum_{j=0}^{n-1}\left(\sum_{i=0}^{n-1}a_i\omega_n^{ij}\right)\omega_n^{-jk}=\sum_{i=0}^{n-1}a_i\sum_{j=0}^{n-1}\omega_n^{ij}\omega_n^{-jk}
=\sum_{i=0}^{n-1}a_i\sum_{j=0}^{n-1}\omega_n^{(i-k)j}
$$

注意到当$i=k$时有

$$
\sum_{j=0}^{n-1}\omega_n^{(i-k)j}=\sum_{j=0}^{n-1}1^j=n
$$

当$i \neq k$时有

$$
\sum_{j=0}^{n-1}\omega_n^{(i-k)j}=\frac{1-\omega_n^{(i-k)n}}{1-\omega_n^{i-k}}=\frac{1-1}{1-\omega_n^{i-k}}=0
$$

所以$c_k=na_k$

#### 快速数论变换（原根变换）

在一般的FFT中，取$\omega_n=\cos \frac {2 \pi}{n}+i \sin \frac {2 \pi}{n}$并在复数域上进行运算即可。在系数较大时会产生精度问题，但使用`long double`可大幅度提升精度与TLE风险。

有时我们面对的问题是模素数意义下的，这时我们可以考虑直接在模素数有限域下解决快速傅里叶变换的问题。对于素数$p=2^k r+1$，模$p$域乘法群为$p-1$次循环群$Z_{p-1}$，且有子群$Z_{2^k}=\{g^{ri}|i \in \{0,1,...,2^k-1\}\}$，其生成元的阶为$2^k$，于是我们可取$\omega_n=g^r$这里$g$为模$p$意义下的原根。因此对于素数$p=2^kr+1$，我们可在模$p$意义下进行长度为$2^k$的FFT。

```cpp
const int W = 19, S = 1 << W, g = 3;
int fr[W][S], fw[2][S];

void init() {
    for (int s = 1; s != W; ++s)
        for (int i = 0; i != (1 << s); ++i)
            fr[s][i] = (fr[s][i>>1]>>1)|((i&1)<<(s-1));
    fw[0][0] = fw[1][0] = 1;
    fw[0][1] = qpm(g, (P - 1) / (1 << W));
    fw[1][1] = inv(fw[0][1]);
    for (int i = 2; i != (1 << W); ++i) {
        fw[0][i] = mul(fw[0][i - 1], fw[0][1]);
        fw[1][i] = mul(fw[1][i - 1], fw[1][1]);
    }
}

int fs, ft;
void init(int n) {
    for (fs = 1, ft = 0; fs < n; fs <<= 1, ++ft);
}

void ntt(int* p, int t) {
    for (int i=0;i!=fs;++i) if (i<fr[ft][i]) swap(p[i],p[fr[ft][i]]);
    for (int i = 1, s = 0; i != fs; i <<= 1, s++)
        for (int j = 0; j != fs; j += (i << 1))
            for (int k = 0; k != i; ++k) {
                int u=p[j+k],v=mul(fw[t][k<<(W-s-1)],p[i+j+k]);
                p[j+k] = add(u, v), p[i+j+k] = sub(u, v);
            }
    for (int i=0,x=inv(fs);t&&i!=fs;++i) p[i]=mul(p[i],x);
}
```

#### 卷积

给定$f(x),g(x)$，求$h(x)=f(x)g(x)$。

对$f(x)$与$g(x)$分别进行FFT/NTT，计算逐点乘积后进行逆变换即可。

在$n$小的时候暴力计算可减小常数。

```cpp
vector<int> mul0(const vector<int>& p1, const vector<int>& p2) {
    int n1 = p1.size(), n2 = p2.size(), n3 = n1 + n2 - 1;
    vector<int> p3(n3);
    for (int i = 0; i != n1; ++i)
        for (int j = 0; j != n2; ++j)
            p3[i + j] = add(p3[i + j], mul(p1[i], p2[j]));
    return p3;
}

vector<int> mul(const vector<int>& p1, const vector<int>& p2, int n = 0) {
    int n1 = p1.size(), n2 = p2.size(), n3 = n1 + n2 - 1;
    vector<int> pr(n3);
    if (n3 > 150) {
        init(n3 + 1);
        copy_n(p1.begin(), n1, pa); fill(pa + n1, pa + fs, 0);
        copy_n(p2.begin(), n2, pb); fill(pb + n2, pb + fs, 0);
        ntt(pa, 0); ntt(pb, 0);
        for (int i = 0; i != fs; ++i) pc[i] = mul(pa[i], pb[i]);
        ntt(pc, 1); copy(pc, pc + n3, pr.begin());
    }
    else pr = mul0(p1, p2);
    if (n && pr.size() > n) pr.resize(n, 0);
    return pr;
}
```

#### 缩放

给定$f(x)$，求$g(x)=f(kx)$

$$g(x)=f(kx)=\sum_{i=0}^{n-1}{a_ik^ix^i}$$

#### 平移

给定$f(x)$，求$g(x)=f(x+\delta)$。

$$
f(x+\delta)=\sum_{i=0}^{n-1}{a_i\sum_{j=0}^i{\binom ij x^j \delta^{i-j}}}
=\sum_{j=0}^{n-1} x^j \sum_{i=j}^{n-1}{\binom ij a_i \delta^{i-j}}
$$

$$
=\sum_{j=0}^{n-1} x^j \sum_{i=0}^{n-j-1} \binom {n-i-1}{j}a_{n-i-1}\delta^{n-i-j-1}
=\sum_{j=0}^{n-1} x^{n-j-1} \sum_{i=0}^{j} \binom {n-i-1}{n-j-1} a_{n-i-1}\delta^{j-i}
$$

令$c_i=a_{n-i-1}(n-i-1)!$，$d_i=\frac{\delta^i}{i!}$

$$
=\sum_{j=0}^n \frac{x^{n-j}}{(n-j)!}\sum_{i=0}^j \frac{(n-i)!}{(j-i)!}a_{n-i} \delta^{j-i}
=\sum_{j=0}^n\frac{x^{n-j}}{(n-j)!}\sum_{i=0}^j c_i d_{j-i}
$$

将序列c与序列d卷起来再乘以阶乘即可。

```cpp
vector<int> shift(const vector<int>& a, ll d) {
    int n = a.size();
    vector<int> b = a, c(n);
    reverse(b.begin(), b.end());
    for (int i = 0; i != n; ++i) {
        b[i] = mul(b[i], f[n - i - 1]);
        if (!i) c[i] = 1;
        else c[i] = mul(c[i - 1], mul(d, invs[i]));
    }
    vector<int> r = mul(b, c, n);
    reverse(r.begin(), r.end());
    return egf(r);
}
```

#### 求导

给定$f(x)$，求$g(x)=f'(x)$。

$$g(x)=\sum_{i=0}^{n-2}(i+1)a_{i+1}x^i$$

```cpp
vector<int> deriv(const vector<int>& p1) {
    int n1 = p1.size();
    vector<int> p2(n1 - 1);
    for (int i = 1; i != n1; ++i) p2[i - 1] = mul(i, p1[i]);
    return p2;
}
```

#### 积分

给定$f(x)=\sum_{i=0}^{n-1}{a_ix^i}$，求$g(x)=\int_0^x{f(t)}dt$。

$$g(x)=\sum_{i=1}^{n}{\frac{a_{i-1}}{i}x^i}$$

```cpp
vector<int> integ(const vector<int>& p1) {
    int n1 = p1.size();
    vector<int> p2(n1 + 1, 0);
    for (int i = 0; i != n1; ++i) p2[i + 1] = mul(p1[i], invs[i + 1]);
    return p2;
}
```

#### 牛顿迭代

注：以下涉及到牛顿迭代过程中的$\frac n2$均自动向上取整。

给定多项式$t(g)$，求$g(x)$使得$t(g) \equiv 0 \mod x^n$。

设已求出$h(x)$使得$t(h) \equiv 0 \mod x^\frac n2$。

因为有$t(g) \equiv 0 \mod x^n$，所以有$t(g) \equiv 0 \mod x^\frac n2$，因此$g(x) \equiv h(x) \mod x^\frac n2$。

考虑$t(g)$在$h$处的泰勒展开

$$t(g) \equiv \sum_{k=0}^\infty \frac {t^{(k)}(h)}{k!}(g(x)-h(x))^k \mod x^n$$

因为$g(x)-h(x) \equiv 0 \mod x^ \frac n2$，所以第二项往后的项全部为0，我们得到

$$
0 \equiv t(g) \equiv t(h)+t'(h)(g-h) \mod x^n
$$

解得

$$
g \equiv h- \frac{t(h)}{t'(h)} \mod x^n
$$

边界：当$n=1$时根据具体情况处理。

#### 求逆

前置：卷积

给定$f(x)$，求$g(x)$使得$f(x)g(x) \equiv 1 \mod x^{n}$。

考虑牛顿迭代：设$t(g)=\frac 1g-f$，则迭代方程为

$$
g(x) = h(x)-\frac{\frac{1}{h(x)}-f(x)}{-\frac{1}{h^2(x)}}=2h(x)-h^2(x)f(x) \mod x^n
$$

边界：当$n=1$时直接求常数的乘法逆即可。

```cpp
vector<int> inv(const vector<int>& p1) {
    int n1 = p1.size(), n2 = (n1 + 1) >> 1;
    if (n1 == 1) return { ::inv(p1[0]) };
    vector<int> p2 = inv(vector<int>(p1.begin(), p1.begin() + n2));
    return sub(mul(p2, 2), mul(p1, mul(p2, p2, n1), n1));
}
```

#### 开根号

前置：卷积，求逆

给定$f(x)$，求$g(x)$使得$g(x)^2 \equiv f(x) \mod x^{n}$。

考虑牛顿迭代：设$t(g)=g^2-f$，则迭代方程为

$$
g(x)=h(x)-\frac{h^2(x)-f(x)}{2h(x)}=\frac{h^2(x)+f(x)}{2h(x)} \mod x^n
$$

边界：当$n=1$时直接求常数的模意义下二次剩余即可。

```cpp
int msqrt(int n) {
    if (!n) return 0;
    int q = P - 1, s = 0, z = 2;
    //while (~q & 1) q >>= 1, s++;
    q >>= (s = __builtin_ctzll(q));
    if (s == 1) return qpm(n, (P + 1) / 4);
    while(qpm(z, (P - 1) / 2) == 1) ++z;
    int c = qpm(z, q), t = qpm(n, q),
       r = qpm(n, (q + 1) / 2), m = s;
    while(t % P != 1) {
        ll i = 1; while(qpm(t, 1ll << i) != 1) ++i;
        ll b = qpm(c, 1ll << (m - i - 1));
        r = mul(r, b); c = mul(b, b);
        t = mul(t, c); m = i;
    }
    return min(r, P - r);
}

vector<int> sqrt(const vector<int>& p1) {
    int n1 = p1.size(), n2 = (n1 + 1) >> 1;
    if (n1 == 1) return { ::msqrt(p1[0]) };
    else {
        vector<int> p2 = sqrt(vector<int>(p1.begin(), p1.begin() + n2));
        vector<int> p3 = mul(p2, 2); p3.resize(n1);
        p3 = inv(p3);
        return mul(add(mul(p2, p2, n1), p1), p3, n1);
    }
}
```

#### 除法与取模

前置：卷积，求逆

给定$f(x)$与$g(x)$，求$q(x)$与$r(x)$使得$f(x)=q(x)g(x)+r(x)$。

其中$q(x)$为$n-m+1$次多项式，$r(x)$为$m-1$次多项式。

考虑将$f(x)$的系数前后翻转

$$f_R(x)=x^{n-1}f(\frac 1x)=\sum_{i=0}^{n-1}a_ix^{n-i-1}$$

将$\frac 1x$作为参数带入上式并两边乘上$x^{n-1}$可得

$$x^{n-1}f(\frac 1x)=x^{n-m+1}q(\frac 1x) x^{m-1}g(\frac 1x)+x^{n-m+1} x^{m-1} r(\frac 1x)$$

$$f_R(x)=q_R(x)g_R(x)+x^{n-m+1}r_R(x)$$

$$f_R(x)=q_R(x)g_R(x) \mod x^{n-m+1}$$

$$q_R(x)=f_R(x)g_R^{-1}(x) \mod x^{n-m+1}$$

对$g_R$多项式求逆后卷上$f_R(x)$并抛掉多余系数即可得到$q_R(x)$，进一步可求出$r_R(x)$。

```cpp
pair<vector<int>, vector<int>> div(const vector<int>& p1, const vector<int>& p2) {
    int n1 = p1.size(), n2 = p2.size(), n3 = n1 - n2 + 1;
    if (n3 <= 0) return { { 0 }, p1 };
    vector<int> p1r = p1, p2r = p2;
    reverse(p1r.begin(), p1r.end());
    reverse(p2r.begin(), p2r.end());
    p1r.resize(n3, 0); p2r.resize(n3, 0);
    vector<int> p3 = mul(p1r, inv(p2r), n3);
    reverse(p3.begin(), p3.end());
    vector<int> p4 = sub(p1, mul(p2, p3));
    p4.resize(n2 - 1, 0);
    return { p3, p4 };
}
```

注：`first`是$q(x)$，`second`是$r(x)$。

#### 对数

前置：卷积，求逆，求导，积分

给定$f(x)$，求$g(x)=\ln f(x)$。

$$g(x)=\ln f(x)=\int_0^{x}\frac{f'(t)}{f(t)}dt$$

```cpp
vector<int> log(const vector<int>& p1) {
    return integ(mul(deriv(p1), inv(p1), p1.size() - 1));
}
```

#### 指数

前置：卷积，对数

给定$f(x)$，求$g(x)=\exp f(x) \mod x^n$。其中$f(0)=a_0=0$

考虑牛顿迭代：设$t(g)=\ln g-f$，则迭代方程为

$$
g(x)=h(x)-\frac{\ln h-x}{\frac{1}{h}}=h(x)(1- \ln h+f) \mod x^n
$$

边界：当$n=1$时返回常数1。

```cpp
vector<int> exp(const vector<int>& p1) {
    if (p1.size() == 1) return { 1 };
    else {
        vector<int> p2 = exp({p1.begin(),p1.begin()+(p1.size()+1>>1)});
        p2.resize(p1.size(), 0);
        return mul(p2, add(sub({ 1 }, log(p2)), p1), p1.size());
    }
}
```

#### 多点求值

给定$f(x)$，和$x_i, i \in \{1, 2, ..., m\}$，求$f(x_i), i \in \{1,2,...,m\}$

构造多项式$g(x)=\prod_{i=1}^m(x-x_i)$，注意到$g(x_i)=0$，考虑多项式除法

$$f(x_i)=q(x_i)g(x_i)+r(x_i)=r(x_i)$$

对$g$取模后只需对$r$求值即可。

$g_{l,r}=\prod_{i=l}^{r}(x-x_i)$可分治求出，将中间结果保存至线段树上后再进行分治，即将对$f$求其在$x_i,i \in \{l,...,r\}$上的值分治为求$f \mod g_{l,mid-1}$在$x_i,i \in \{l,...,mid-1\}$上的值和求$f \mod g_{mid,r}$在$x_i,i \in \{mid,...,r\}$上的值。因NTT常数巨大，所以在分治到一定程度时直接转秦九韶暴力求值可降低常数。

```cpp
int eval(const vector<int>& p, int x) {
    int r = 0;
    for (int i = (int)p.size() - 1; i >= 0; --i)
        r = add(p[i], mul(r, x));
    return r;
}

vector<int> est[N];

void eval0(const vector<int>& x, int p, int lb, int rb) {
    if (lb + 1 == rb) est[p] = { sub(0, x[lb]), 1 };
    else {
        int mid = (lb + rb) >> 1;
        eval0(x, p << 1, lb, mid);
        eval0(x, p << 1 | 1, mid, rb);
        est[p] = mul(est[p << 1], est[p << 1 | 1]);
    }
}

void eval1(const vector<int>& r, const vector<int>& x,
            int p, int lb, int rb) {
    vector<int> w = div(r, est[p]).second;
    if (lb + 101 >= rb)
        for (int i = lb; i != rb; ++i)
            est[0][i] = eval(w, x[i]);
    else {
        int mid = (lb + rb) >> 1;
        eval1(w, x, p << 1, lb, mid);
        eval1(w, x, p << 1 | 1, mid, rb);
    }
}

vector<int> eval(const vector<int>& p, const vector<int>& x) {
    eval0(x, 1, 0, x.size());
    est[0].resize(x.size());
    eval1(p, x, 1, 0, x.size());
    return est[0];
}
```

## 线性基

```cpp
typedef bitset<W> bv;
typedef array<bv, W> bs;

bool ins(bs& b, bv v, bool flg = 1) {
    for (int i = W - 1; i >= 0; --i) {
        if (!v[i]) continue;
        if (!b[i][i]) {
            if (flg) b[i] = v;
            return true;
        }
        else v ^= b[i];
    }
    return false;
}

bs bunion(const bs& b1, const bs& b2) {
    bs r = b1;
    for (int i = 0; i != W; ++i)
        if (b2[i].any()) ins(r,b2[i]);
    return r;
}

bs bitsc(const bs& b1, const bs& b2) {
    bs b = b1, t, r;
    for (int i = W - 1; i >= 0; --i) {
        if (!b2[i][i]) continue;
        bv v = b2[i], k; k[i] = 1; bool f = 1;
        for (int j = W - 1; j >= 0; --j) {
            if (!v[j]) continue;
            if (b[j].any()) v ^= b[j], k ^= t[j];
            else { b[j] = v; t[j] = k; f = 0; break; }
        }
        if (!f) continue;
        bv w;
        for (int j = 0; j != W; ++j)
            if (k[j]) w ^= b2[j];
        ins(r, w);
    }
    return r;
}

bv qmax(const bs& b) {
    bv v;
    for (int i = W - 1; i >= 0; --i)
        if (!v[i] && b[i][i]) v ^= b[i];
    return v;
}
```

## 快速变换与卷积

### FFT

```cpp

typedef double dbl;
typedef complex<dbl> cplx;
const dbl pi = acos(-1);

int fr[N], fs;
void init(int s) {
    for (fs = 1; fs <= s; fs <<= 1);
    for (int i = 0; i != fs; ++i)
        fr[i] = (fr[i >> 1] >> 1) | (i & 1 ? (fs >> 1) : 0);
}

void fft(cplx* p, int f) {
    for (int i = 0; i != fs; ++i) if (i < fr[i]) swap(p[i], p[fr[i]]);
    for (int i = 1; i != fs; i <<= 1) {
        cplx w0{ cos(pi / i), f * sin(pi / i) };
        for (int j = 0; j != fs; j += (i << 1)) {
            cplx w{ 1, 0 };
            for (int k = 0; k != i; k++) {
                cplx u = p[j + k], v = w * p[i + j + k];
                p[j + k] = u + v; p[i + j + k] = u - v;
                w *= w0;
            }
        }
    }
}

void fft_res(cplx* p) {
    for (int i = 0; i != fs; ++i)
        p[i] = p[i] * (1. / fs);
}

cplx p1[N], p2[N], p3[N];
int conv(int* a, int n, int* b, int m, int* c) {
    init(n + m + 1);
    for (int i = 0; i <= n; ++i) p1[i] = a[i];
    fill(p1 + n + 1, p1 + fs, cplx{});
    for (int i = 0; i <= m; ++i) p2[i] = b[i];
    fill(p2 + m + 1, p2 + fs, cplx{});
    fft(p1, 1); fft(p2, 1);
    for (int i = 0; i != fs; ++i) p3[i] = p1[i] * p2[i];
    fft(p3, -1); fft_res(p3);
    for (int i = 0; i != fs; ++i) c[i] = round(p3[i].real());
    return fs;
}
```

### NTT

### FWT

$$h(U)=\sum_{S \circ T=U}f(S)g(T)$$

FWT|&|\||^||IFWT|&|\||^
-|-|-|-|-|-|-|-|-
`a[i+j]=`|`x+y`|`x`|`x+y`||`a[i+j]=`|`x-y`|`x`|`(x+y)/2`
`a[i+j+k]=`|`y`|`x+y`|`x-y`||`a[i+j+k]=`|`y`|`y-x`|`(x-y)/2`

```cpp

void fwt(ll* a, int n) {
    for (int k = 1; k < n; k <<= 1)
        for (int m = k << 1, i = 0; i < n; i += m)
            for (int j = 0; j != k; j++) {
                ll x = a[i + j], y = a[i + j + k];
                //a[i + j] = ...
                //a[i + j + k] = ...
            }
}
```

### FZT/FMT

详见 数学-组合.pdf

FZT($\zeta$变换):$$g(S)=\sum_{T \subseteq S}f(T)$$

FMT($\mu$变换): $$g(S)=\sum_{T \subseteq S}{(-1)^{|S|-|T|}f(T)}$$

```cpp

void fzt(ll* f, ll* g, int w) {
    copy_n(f, 1 << w, g);
    for (int i = 0; i != w; ++i)
        for (int j = 0; j != (1 << w); ++j)
            if (j & (1 << i)) g[j] += g[j ^ (1 << i)];
}

void fmt(ll* f, ll* g, int w) {
    copy_n(f, 1 << w, g);
    for (int i = 0; i != w; ++i)
        for (int j = 0; j != (1 << w); ++j)
            if (j & (1 << i)) g[j] -= g[j ^ (1 << i)];
}
```

另一种形式：

FZT($\zeta$变换):$$g(S)=\sum_{T \supseteq S}f(T)$$

FMT($\mu$变换): $$g(S)=\sum_{T \supseteq S}{(-1)^{|T|-|S|}f(T)}$$

```cpp
void fzt(ll* f, ll* g, int w) {
    copy_n(f, 1 << w, g);
    for (int i = 0; i != w; ++i)
        for (int j = 0; j != (1 << w); ++j)
            if (j & (1 << i)) g[j ^ (1 << i)] += g[j];
}

void fmt(ll* f, ll* g, int w) {
    copy_n(f, 1 << w, g);
    for (int i = 0; i != w; ++i)
        for (int j = 0; j != (1 << w); ++j)
            if (j & (1 << i)) g[j ^ (1 << i)] -= g[j];
}
```

## 概率

### 随机游走

#### 有限图上的随机游走

定义：

1. $p_{uv}$表示当前在$u$，下一步在$v$的概率。
2. $p^{(k)}_{uv}$表示当前在$u$，$k$步后在$v$的概率。
3. $p^{(k)}_{uv}=\sum_{w \in N(u)}{p_{uw}p^{k-1}_{wv}}$
4. 转移矩阵$P$的第$i$行第$j$列元素为$p_{ji}$。
5. k步转移矩阵$P^{k}$第$i$行第$j$列元素为$p^{(k)}_{ji}$。
6. $X^{(0)}$为初始态列向量，$X^{(0)}_u$为初始状态时点在$u$的概率。
7. $X^{(k)}=P^kX^{(0)}$为进行$k$次转移后的状态。

期望问题：计算从一些点（给定概率）出发到达某个终末点$t$的期望步数/消耗。

注：在这个问题中，无论原图如何，都需要将$t$点的出边删去并指向虚空，即$\forall u \in V, p_{tu}=0$。

但特别的，有$p^{(0)}_{tt}=1$

设$P(u)$为从$u$出发，经过无限步后到达$t$的概率。特别的$P(t)=1$。

$$P(u)=\sum_{k=1}^{\infty}{p^{(k)}_{ut}}=\sum_{k=1}^{\infty}{\sum_{v \in N(u)}{p_{uv}p^{(k-1)}_{vt}}}=\sum_{v\in N(u)}{p_{uv}\sum_{k=1}^{\infty}}{p^{(k-1)}_{vt}{}}$$
$$=p_{vt}+\sum_{t \neq v \in N(u)}{p_{uv}P(v)}=\sum_{v \in N(u)}{p_{uv}P(v)}$$

设$E(u)$为从$u$出发，到达$t$的期望转移次数。特别的，$E(t)=0$。

$$E(u)=\sum_{k=1}^{\infty}{kp^{(k)}_{ut}}=\sum_{k=1}^{\infty}{k\sum_{v \in N(u)}{p_{uv}p^{(k-1)}_{vt}}}=\sum_{v \in N(u)}{p_{uv}\sum_{k=1}^{\infty}{kp^{(k-1)}_{vt}}}$$

$$=p_{ut}+\sum_{t \neq v \in N(u)}{p_{uv}\sum_{k=1}^{\infty}{(k+1)p^{(k)}_{vt}}}=p_{ut}+\sum_{t\neq v \in N(u)}{p_{uv}\left(\sum_{k=1}^{\infty}{kp_{vt}}+\sum_{k=1}^{\infty}{p_{vt}}\right)}$$

$$=p_{ut}+\sum_{t \neq v \in N(u)}{p_{uv}(E(v)+P(v))}=\sum_{v \in N(u)}{p_{uv}(P(v)+E(v))}$$

设$F(u)$为从$u$出发，到达$t$的期望消耗。其中第$k$步的消耗为$k$。特别的，$F(t)=0$。

$$F(u)=\sum_{k=1}^{\infty}{\frac{k(k+1)}{2}p^{(k)}_{ut}}=\sum_{k=1}^{\infty}{\frac{k(k+1)}{2}\sum_{v \in N(u)}{p_{uv}p^{(k-1)}_{vt}}}=\sum_{v \in N(u)}{p_{uv}\sum_{k=1}^{\infty}{\frac{k(k+1)}{2}p^{(k-1)}_{vt}}}$$

$$=p_{ut}+\sum_{n \neq v \in N(u)}{p_{uv}\sum_{k=1}^{\infty}{\frac{k(k+1)}{2}p^{(k-1)}_{vt}}}=p_{ut}+\sum_{n \neq v \in N(u)}{p_{uv}\sum_{k=1}^{\infty}{\frac{(k+1)(k+2)}{2}p^{(k)}_{vt}}}$$

$$=p_{ut}+\sum_{n \neq v \in N(u)}{p_{uv}\sum_{k=1}^{\infty}{\left[\frac{k(k+1)}{2}+k+1\right]p^{(k)}_{vt}}}=p_{ut}+\sum_{n \neq v \in N(u)}{p_{uv}\left[\sum_{k=1}^{\infty}{\frac{k(k+1)}{2}p^{(k)}_{vt}}+\sum_{k=1}^{\infty}{kp^{(k)}_{vt}}+\sum_{k=1}^{\infty}{p^{(k)}_{vt}}\right]}$$

$$=p_{ut}+\sum_{n\neq v \in N(u)}{p_{uv}[F(v)+E(v)+P(v)]}=\sum_{v \in N(u)}{p_{uv}[F(v)+E(v)+P(v)]}$$

推广：

设$F_m(u)$表示从$u$出发，到达$t$的期望消耗，其中第$k$步消耗为$k^m$。特别的，$F_m(t)=0$，$F_0(u)=P(u)$，$F_1(u)=E(u)$。

$$F_m(u)=\sum_{v\in N(u)}{p_{uv}\sum_{k=1}^{\infty}{k^m p^{(k-1)}_{vt}}}=p_{ut}+\sum_{t \neq v\in N(u)}{p_{uv}\sum_{k=1}^{\infty}{(k+1)^mp_{vt}}}$$

$$=p_{ut}+\sum_{t \neq v\in N(u)}{p_{uv}\sum_{k=1}^{\infty}{\sum_{i=0}^{m}{\binom {m}{i}k^i}p_{vt}}}=p_{ut}+\sum_{t \neq v\in N(u)}{p_{uv}\sum_{i=0}^{m}{\binom {m}{i}\sum_{k=1}^{\infty}{k^i}p_{vt}}}$$

$$=\sum_{v \in N(u)}{p_{uv}\sum_{i=0}^{m}{\binom{m}{i}F_i(v)}}$$

设$E_P(u)$表示从$u$出发，到达$t$的期望消耗，其中第$k$步消耗为$P(k)=\sum_{i=0}^{\infty}{a_ik^i}$。特别的，$E_P(t)=0$。

$$E_P(u)=\sum_{k=1}^{\infty}{\sum_{i=0}^{\infty}{\sum_{v\in N(u)}a_ik^ip_{uv}p^{(k-1)}_{vt}}}=\sum_{v\in N(u)}{p_{uv}\sum_{k=1}^{\infty}{\sum_{i=0}^{\infty}{a_ik^ip^{(k-1)}_{vt}}}}$$

$$=\sum_{v \in N(u)}{p_{uv}\sum_{i=0}^{\infty}a_i\sum_{k=1}^{\infty}{(k+1)^ip^{(k)}_{vt}}}=\sum_{v \in N(u)}{p_{uv}\sum_{i=0}^{\infty}{a_i\sum_{j=0}^{i}{\binom ij \sum_{k=1}^{\infty}{k^{j}p_{vt}^{k}}}}}$$

$$=\sum_{v \in N(u)}{p_{uv}\sum_{j=0}^{\infty}{F_{j}(v)\sum_{i=j}^{\infty}{a_i\binom ij}}}$$

#### 无限图上的随机游走

##### 一维直线上的随机游走

无限制：

从原点出发，每次必须往左/右走一步，则时刻$t$在位置$x$的概率为0当且仅当$x>t$或$2 \nmid (x+t)$，否则为$\frac{1}{2^t}\binom {t}{\frac{t-x}{2}}$。

从原点出发，

有限制：

从原点出发，每次可以选择往左右走，但不允许越过原点。默慈金数（允许不动）/卡塔兰数（必须动）。

##### 二维平面网格上的随机游走

无限制：

从原点出发，每次必须往四个方向$(-1,0),(1,0),(0,-1),(0,1)$等概率走一步：

进行坐标变换$(u,v)=(x+y,x-y)$，则相当于每次必须往$(-1,-1),(-1,1),(1,-1),(1,1)$等概率走一步，发现两维互相独立，于是时刻$t$在位置$(u,v)$的概率为0当且仅当$u>t$或$v>t$或$2 \nmid u$或$2 \nmid v$，否则为$\frac{1}{2^{2t}}\binom{t}{\frac{t-u}{2}}\binom{t}{\frac{t-v}{2}}$。逆变换得$\frac{1}{2^{2t}}\binom{t}{\frac{t-x-y}{2}}\binom{t}{\frac{t-x+y}{2}}$。

有限制：

考虑通过坐标变换转化为两维互相独立的一维随机游走。

##### 更高维的情况

三维空间中，从原点出发，每次必须往八个方向$$(-1,0,0),(1,0,0),(0,-1,0),(0,1,0),(0,0,-1),(0,0,1),(-1,-1,-1),(1,1,1)$$等概率走一步

进行坐标变换$(u,v,w)=(x+y-z,y+z-x,z+x-y)$

注：有逆变换$(x,y,z)=(\frac{u+w}{2},\frac{u+v}{2},\frac{v+w}{2})$

方向|$(1,1,1)$|$(0,1,0)$|$(1,0,0)$|$(0,0,-1)$|$(0,0,1)$|$(-1,0,0)$|$(0,-1,0)$|$(-1,-1,-1)$
-|-|-|-|-|-|-|-|-
$u$|$1$|$1$|$1$|$1$|$-1$|$-1$|$-1$|$-1$
$v$|$1$|$1$|$-1$|$-1$|$1$|$1$|$-1$|$-1$
$w$|$1$|$-1$|$1$|$-1$|$1$|$-1$|$1$|$-1$

观察到三维互相独立，因此$t$时刻在$(x,y,z)$的概率为$$\frac{1}{2^{3t}}\binom {t}{\frac{t-(x+y-z)}{2}}\binom {t}{\frac{t-(y+z-x)}{2}}\binom {t}{\frac{t-(z+x-y)}{2}}$$

注意无法整除时为$0$。

## 高精度类

### 高精度整数

```cpp
#define pb push_back
#define mp make_pair
typedef pair<int,int> pii;

typedef double ld;
typedef vector<int> vi;
#define fi first
#define se second

// base and base_digits must be consistent
constexpr int base = 1000000000;
constexpr int base_digits = 9;

struct bigint {
  // value == 0 is represented by empty z
  vector<int> z;  // digits

  // sign == 1 <==> value >= 0
  // sign == -1 <==> value < 0
  int sign;

  bigint() : sign(1) {}

  bigint(long long v) { *this = v; }

  bigint& operator=(long long v) {
    sign = v < 0 ? -1 : 1;
    v *= sign;
    z.clear();
    for (; v > 0; v = v / base) z.push_back((int)(v % base));
    return *this;
  }

  bigint(const string& s) { read(s); }

  bigint& operator+=(const bigint& other) {
    if (sign == other.sign) {
      for (int i = 0, carry = 0; i < other.z.size() || carry; ++i) {
        if (i == z.size()) z.push_back(0);
        z[i] += carry + (i < other.z.size() ? other.z[i] : 0);
        carry = z[i] >= base;
        if (carry) z[i] -= base;
      }
    } else if (other != 0 /* prevent infinite loop */) {
      *this -= -other;
    }
    return *this;
  }

  friend bigint operator+(bigint a, const bigint& b) { return a += b; }

  bigint& operator-=(const bigint& other) {
    if (sign == other.sign) {
      if (sign == 1 && *this >= other || sign == -1 && *this <= other) {
        for (int i = 0, carry = 0; i < other.z.size() || carry; ++i) {
          z[i] -= carry + (i < other.z.size() ? other.z[i] : 0);
          carry = z[i] < 0;
          if (carry) z[i] += base;
        }
        trim();
      } else {
        *this = other - *this;
        this->sign = -this->sign;
      }
    } else {
      *this += -other;
    }
    return *this;
  }

  friend bigint operator-(bigint a, const bigint& b) { return a -= b; }

  bigint& operator*=(int v) {
    if (v < 0) sign = -sign, v = -v;
    for (int i = 0, carry = 0; i < z.size() || carry; ++i) {
      if (i == z.size()) z.push_back(0);
      long long cur = (long long)z[i] * v + carry;
      carry = (int)(cur / base);
      z[i] = (int)(cur % base);
    }
    trim();
    return *this;
  }

  bigint operator*(int v) const { return bigint(*this) *= v; }

  friend pair<bigint, bigint> divmod(const bigint& a1, const bigint& b1) {
    int norm = base / (b1.z.back() + 1);
    bigint a = a1.abs() * norm;
    bigint b = b1.abs() * norm;
    bigint q, r;
    q.z.resize(a.z.size());

    for (int i = (int)a.z.size() - 1; i >= 0; i--) {
      r *= base;
      r += a.z[i];
      int s1 = b.z.size() < r.z.size() ? r.z[b.z.size()] : 0;
      int s2 = b.z.size() - 1 < r.z.size() ? r.z[b.z.size() - 1] : 0;
      int d = (int)(((long long)s1 * base + s2) / b.z.back());
      r -= b * d;
      while (r < 0) r += b, --d;
      q.z[i] = d;
    }

    q.sign = a1.sign * b1.sign;
    r.sign = a1.sign;
    q.trim();
    r.trim();
    return {q, r / norm};
  }

  friend bigint sqrt(const bigint& a1) {
    bigint a = a1;
    while (a.z.empty() || a.z.size() % 2 == 1) a.z.push_back(0);

    int n = a.z.size();

    int firstDigit = (int)::sqrt((double)a.z[n - 1] * base + a.z[n - 2]);
    int norm = base / (firstDigit + 1);
    a *= norm;
    a *= norm;
    while (a.z.empty() || a.z.size() % 2 == 1) a.z.push_back(0);

    bigint r = (long long)a.z[n - 1] * base + a.z[n - 2];
    firstDigit = (int)::sqrt((double)a.z[n - 1] * base + a.z[n - 2]);
    int q = firstDigit;
    bigint res;

    for (int j = n / 2 - 1; j >= 0; j--) {
      for (;; --q) {
        bigint r1 =
            (r - (res * 2 * base + q) * q) * base * base +
            (j > 0 ? (long long)a.z[2 * j - 1] * base + a.z[2 * j - 2] : 0);
        if (r1 >= 0) {
          r = r1;
          break;
        }
      }
      res *= base;
      res += q;

      if (j > 0) {
        int d1 = res.z.size() + 2 < r.z.size() ? r.z[res.z.size() + 2] : 0;
        int d2 = res.z.size() + 1 < r.z.size() ? r.z[res.z.size() + 1] : 0;
        int d3 = res.z.size() < r.z.size() ? r.z[res.z.size()] : 0;
        q = (int)(((long long)d1 * base * base + (long long)d2 * base + d3) /
                  (firstDigit * 2));
      }
    }

    res.trim();
    return res / norm;
  }

  bigint operator/(const bigint& v) const { return divmod(*this, v).first; }

  bigint operator%(const bigint& v) const { return divmod(*this, v).second; }

  bigint& operator/=(int v) {
    if (v < 0) sign = -sign, v = -v;
    for (int i = (int)z.size() - 1, rem = 0; i >= 0; --i) {
      long long cur = z[i] + rem * (long long)base;
      z[i] = (int)(cur / v);
      rem = (int)(cur % v);
    }
    trim();
    return *this;
  }

  bigint operator/(int v) const { return bigint(*this) /= v; }

  int operator%(int v) const {
    if (v < 0) v = -v;
    int m = 0;
    for (int i = (int)z.size() - 1; i >= 0; --i)
      m = (int)((z[i] + m * (long long)base) % v);
    return m * sign;
  }

  bigint& operator*=(const bigint& v) {
    *this = *this * v;
    return *this;
  }

  bigint& operator/=(const bigint& v) {
    *this = *this / v;
    return *this;
  }

  bool operator<(const bigint& v) const {
    if (sign != v.sign) return sign < v.sign;
    if (z.size() != v.z.size()) return z.size() * sign < v.z.size() * v.sign;
    for (int i = (int)z.size() - 1; i >= 0; i--)
      if (z[i] != v.z[i]) return z[i] * sign < v.z[i] * sign;
    return false;
  }

  bool operator>(const bigint& v) const { return v < *this; }

  bool operator<=(const bigint& v) const { return !(v < *this); }

  bool operator>=(const bigint& v) const { return !(*this < v); }

  bool operator==(const bigint& v) const {
    return !(*this < v) && !(v < *this);
  }

  bool operator!=(const bigint& v) const { return *this < v || v < *this; }

  void trim() {
    while (!z.empty() && z.back() == 0) z.pop_back();
    if (z.empty()) sign = 1;
  }

  bool isZero() const { return z.empty(); }

  friend bigint operator-(bigint v) {
    if (!v.z.empty()) v.sign = -v.sign;
    return v;
  }

  bigint abs() const { return sign == 1 ? *this : -*this; }

  long long longValue() const {
    long long res = 0;
    for (int i = (int)z.size() - 1; i >= 0; i--) res = res * base + z[i];
    return res * sign;
  }

  friend bigint gcd(const bigint& a, const bigint& b) {
    return b.isZero() ? a : gcd(b, a % b);
  }

  friend bigint lcm(const bigint& a, const bigint& b) {
    return a / gcd(a, b) * b;
  }

  void read(const string& s) {
    sign = 1;
    z.clear();
    int pos = 0;
    while (pos < s.size() && (s[pos] == '-' || s[pos] == '+')) {
      if (s[pos] == '-') sign = -sign;
      ++pos;
    }
    for (int i = (int)s.size() - 1; i >= pos; i -= base_digits) {
      int x = 0;
      for (int j = max(pos, i - base_digits + 1); j <= i; j++)
        x = x * 10 + s[j] - '0';
      z.push_back(x);
    }
    trim();
  }

  friend istream& operator>>(istream& stream, bigint& v) {
    string s;
    stream >> s;
    v.read(s);
    return stream;
  }

  friend ostream& operator<<(ostream& stream, const bigint& v) {
    if (v.sign == -1) stream << '-';
    stream << (v.z.empty() ? 0 : v.z.back());
    for (int i = (int)v.z.size() - 2; i >= 0; --i)
      stream << setw(base_digits) << setfill('0') << v.z[i];
    return stream;
  }

  static vector<int> convert_base(const vector<int>& a, int old_digits,
                                  int new_digits) {
    vector<long long> p(max(old_digits, new_digits) + 1);
    p[0] = 1;
    for (int i = 1; i < p.size(); i++) p[i] = p[i - 1] * 10;
    vector<int> res;
    long long cur = 0;
    int cur_digits = 0;
    for (int v : a) {
      cur += v * p[cur_digits];
      cur_digits += old_digits;
      while (cur_digits >= new_digits) {
        res.push_back(int(cur % p[new_digits]));
        cur /= p[new_digits];
        cur_digits -= new_digits;
      }
    }
    res.push_back((int)cur);
    while (!res.empty() && res.back() == 0) res.pop_back();
    return res;
  }

  typedef vector<long long> vll;

  static vll karatsubaMultiply(const vll& a, const vll& b) {
    int n = a.size();
    vll res(n + n);
    if (n <= 32) {
      for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++) res[i + j] += a[i] * b[j];
      return res;
    }

    int k = n >> 1;
    vll a1(a.begin(), a.begin() + k);
    vll a2(a.begin() + k, a.end());
    vll b1(b.begin(), b.begin() + k);
    vll b2(b.begin() + k, b.end());

    vll a1b1 = karatsubaMultiply(a1, b1);
    vll a2b2 = karatsubaMultiply(a2, b2);

    for (int i = 0; i < k; i++) a2[i] += a1[i];
    for (int i = 0; i < k; i++) b2[i] += b1[i];

    vll r = karatsubaMultiply(a2, b2);
    for (int i = 0; i < a1b1.size(); i++) r[i] -= a1b1[i];
    for (int i = 0; i < a2b2.size(); i++) r[i] -= a2b2[i];

    for (int i = 0; i < r.size(); i++) res[i + k] += r[i];
    for (int i = 0; i < a1b1.size(); i++) res[i] += a1b1[i];
    for (int i = 0; i < a2b2.size(); i++) res[i + n] += a2b2[i];
    return res;
  }

  bigint operator*(const bigint& v) const {
    vector<int> a6 = convert_base(this->z, base_digits, 6);
    vector<int> b6 = convert_base(v.z, base_digits, 6);
    vll a(a6.begin(), a6.end());
    vll b(b6.begin(), b6.end());
    while (a.size() < b.size()) a.push_back(0);
    while (b.size() < a.size()) b.push_back(0);
    while (a.size() & (a.size() - 1)) a.push_back(0), b.push_back(0);
    vll c = karatsubaMultiply(a, b);
    bigint res;
    res.sign = sign * v.sign;
    for (int i = 0, carry = 0; i < c.size(); i++) {
      long long cur = c[i] + carry;
      res.z.push_back((int)(cur % 1000000));
      carry = (int)(cur / 1000000);
    }
    res.z = convert_base(res.z, 6, base_digits);
    res.trim();
    return res;
  }
};
```

<div STYLE="page-break-after: always;"></div>

### 高精度实数

```cpp
#define rep(i,l,r) for(int i=l;i<=r;++i)
#define per(i,r,l) for(int i=r;i>=l;--i)
template <typename T> void chmin(T&x,const T &y) { if(x>y)x=y; }
template <typename T> void chmax(T&x,const T &y) { if(x<y)x=y; }

const int W=1e8,B=20,T=60;
struct db {
    int a[T],n;
    bool is_neg;
    int& operator [](int x) { return a[x]; }
    int operator [](int x) const { return a[x]; }
    void left_move(int l) {
        per(i,n-1,0)a[i+l]=a[i];
        rep(i,0,l-1)a[i]=0; n+=l;
    }
    db (int x=0) {
        memset(a,0,sizeof(a));n=B; is_neg=0;
        if(x<0){is_neg=1;x=-x;}
        while(x){a[n++]=x%W;x/=W;}
    }
    void print(char c='\n')const {
        if(is_neg)putchar('-');
        if(n>B) {
            printf("%d",a[n-1]);
            per(i,n-2,B)printf("%.8d",a[i]);
        }
        else printf("0");
        printf(".");
        per(i,B-1,B-2)printf("%.8d",a[i]);
        printf("%c",c);
    }
    long double evalu(int l)const {
        long double x=0;
        per(i,n-1,l)x=x*W+a[i];
        return x;
    }
};
bool operator <(const db &a,const db &b)
{
    if(a.is_neg) {
        if(!b.is_neg)return 1;
        per(i,T-1,0) if(a[i]!=b[i])return a[i]>b[i];
        return 0;
    }
    else {
        if(b.is_neg)return 0;
        per(i,T-1,0) if(a[i]!=b[i])return a[i]<b[i];
        return 0;
    }
}
bool operator >=(const db &a,const db &b) { return !(a<b); }
bool operator <=(const db &a,const db &b) { return b>=a; }
bool operator >(const db &a,const db &b) { return b<a; }
bool operator !(const db &a) { int n=a.n; while(n&&!a[n-1])--n; return !n;}
db operator -(db a) { a.is_neg^=1; return a; }
db operator +(db a,const db &b);
db operator -(db a,db b) {
    b=-b;
    if(a.is_neg) {
        if(!b.is_neg) { a=-a; swap(a,b); }
        else return a+b;
    }
    else {
        if(b.is_neg) b=-b;
        else return a+b;
    }
    if(a<b)return -(b-a);
    rep(i,0,a.n-1) if((a[i]-=b[i])<0) { a[i]+=W; --a[i+1]; }
    while(a.n&&!a[a.n-1])--a.n;
    return a;
}
db operator +(db a,const db &b)
{
    if(a.is_neg) { if(!b.is_neg) return b-(-a); }
    else { if(b.is_neg)return a-(-b); }
    chmax(a.n,b.n);
    rep(i,0,a.n-1) if((a[i]+=b[i])>=W) { a[i]-=W; ++a[i+1]; }
    if(a[a.n])++a.n;
    return a;
}
void operator +=(db &a,const db &b) { a=a+b; }
void operator -=(db &a,const db &b) { a=a-b; }
db eps1,eps2,eps3;
db operator *(const db &a,const db &b) {
    db ans;
    ans.is_neg=a.is_neg^b.is_neg;
    ans.n=max(0,a.n+b.n-B);
    rep(i,0,ans.n) {
        int jk=i+B;s64 sum=0;
        rep(j,max(0,jk-(b.n-1)),min(jk,a.n-1))sum+=(s64)a[j]*b[jk-j];
        int x=i;
        while(sum) { ans[x]+=sum%W; sum/=W; ++x; }
    }
    rep(i,0,ans.n) while(ans[i]>=W) { ans[i]-=W; ++ans[i+1]; }
    if(ans.n&&!ans[ans.n-1])--ans.n;
    return ans;
}
void operator *=(db &a,const db &b) { a=a*b; }
db operator *(db a,int k) {
    per(i,a.n-1,0) {
        s64 sum=(s64)a[i]*k;
        a[i]=sum%W;
        a[i+1]+=sum/W;
    }
    rep(i,0,a.n-1)
    while(a[i]>=W) { a[i]-=W; ++a[i+1]; }
    if(a[a.n])++a.n;
    return a;
}
db operator *(int k,const db &a) { return a*k; }
db operator /(db a,db b) {
    a.is_neg^=b.is_neg;
    b.is_neg=0;
    a.left_move(B);
    int l=max(0,b.n-20);
    long double b_e=b.evalu(l);
    db x; x.n=0;
    per(i,a.n-1,0) {
        x.left_move(1);
        x[0]=a[i];
        if(x>=b)
        {
            int k=x.evalu(l)/b_e;
            if(k)--k;
            a[i]=k;
            x-=k*b;
            while(x>=b) { x-=b; ++a[i]; }
        }
        else a[i]=0;
    }
    while(a.n && !a[a.n - 1]) --a.n;
    return a;
}
void operator /=(db &a,const db &b) { a = a / b; }
int cmp(const db &x,const db &eps) { return x < -eps ? -1 : x > eps; }
```
