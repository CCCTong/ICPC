# 杂项

## 排列，置换，群

### 按字典序遍历所有排列

```cpp
int p[N]; iota(p + 1, p + n + 1, 1);
do {
    //  ...
} while (next_permutation(p + 1, p + n + 1));
// 改成prev_permutation并将p初始化为n~1即可从大到小遍历
```

### Cantor展开

### 循环分解

### Burnside引理/Polya定理（见组合部分）

## 数值算法

### 拉格朗日插值

已知$f(x)$为次数不超过$n-1$次的多项式与$y_1=f(x_1),y_2=f(x_2),...,y_n=f(x_n)$的值，则$f(x)$在其他任意位置的值可以在$O(n^2)$内求出。

考虑具有特殊性质的多项式

$$p_k(x)=\prod_{i=1,i!=k}^{n}\frac{x-x_i}{x_k-x_i}$$

易知$p_k(x)$在$x_k$处取值为$1$，在其他$x_i$处取值为$0$。那么我们可以直接构造出与$f(x)$恒等的多项式

$$f(x)=\sum_{k=1}^{n}y_kp_k(x)=\sum_{k=1}^{n}{y_k\prod_{i=1,i!=k}^n{\frac{x-x_i}{x_k-x_i}}}$$

当$x_i=x_{i-1}+1$时到$p_k$的分母分子均可快速求出，此时插值可在$O(n)$内完成。

```cpp

//  Lagrangian Interpolation, P(x[0])==y[0], P(x[1])==y[1], ...
ll lintp(const vector<ll>& y, const vector<ll>& x, ll m) {
    int n = y.size(); ll res = 0;
    for (int i = 0; i != n; ++i) {
        ll t = y[i];
        for (int j = 0; j != n; ++j)
            if (j != i)
                t = M(t * M((P+m-x[j]) * inv(P+x[i]-x[j])));
        res = M(res + t);
    }
    return res;
}

//  Lagrangian Interpolation, P(0)==y[0], P(1)==y[1], ...
ll lp[N], ls[N];
ll lintp(const vector<ll>& y, ll x) {
    int n = y.size(); ll res = 0; lp[0] = x; ls[n - 1] = x - (n - 1);
    for (int i = 1; i != n; ++i) lp[i] = M(lp[i - 1] * (x - i));
    for (int i = n - 2; i >= 0; --i) ls[i] = M(ls[i + 1] * (x - i));
    for (int i = 0; i != n; ++i) {
        ll t = (n - i + 1) & 1 ? P - y[i] : y[i];
        if (i)          t = M(t * M(lp[i - 1] * fi[i]));
        if (i != n - 1) t = M(t * M(ls[i + 1] * fi[n - 1 - i]));
        res = M(res + t);
    }
    return res;
}

```

### 高斯消元，零空间

```cpp

#include <bits/stdc++.h>
#define R(m) (int)(m).size()
#define C(m) (int)((m)[0].size())
const dbl eps = 1e-8;
typedef vector<dbl> vec;
typedef vector<vec> mat;

//  Gaussian Elimination, O(n^3)
int row_reduction(mat& a) {
    const int& n = R(a), m = C(a);
    for (int i = 0, j = 0; i != n; ++i) {
        do for (int k = i + 1; k != n; ++k)
            if (fabs(a[i][j]) < fabs(a[k][j]))
                swap(a[i], a[k]);
        while (!dc(a[i][j]) && ++j != n);
        if (j == n) return i; //  rk(a)
        for (int l = m - 1; l >= i; --l)
            a[i][l] /= a[i][j];
        for (int k = 0; k != n; ++k) {
            if (k != i) for (int l = m - 1; l >= i; --l)
                a[k][l] -= a[k][j] * a[i][l];
    }
    return n;
}

//  Get a base of null space of a, O(n^2)
mat nsp(mat& a) {
    const int n = C(a);
    while(R(a) < n) a.push_back(vec(n, 0));
    int w = row_reduction(a); mat b(n, vec(n - w, 0));
    vector<int> p, vis(n, 0);
    for (int c = 0, r = 0; c != n; ++c)
        if (abs(a[r][c]) > eps) ++r, vis[c] = 1;
    for (int i = 0; i != n; ++i) if (vis[i]) p.push_back(i);
    for (int i = 0; i != n; ++i) if (!vis[i]) p.push_back(i);
    for (int i = 0; i != n - w; ++i) {
        for (int j = 0; j != n; ++j)
            b[j][i] = a[p[j]][p[i + w]];
        b[p[i + w]][i] = -1;
    }
    return b;
}
```

### Graham-Schmidt正交化，QR分解

### 实数的分数逼近（Farey序列与Stern-Brocott树）

定义：Farey序列

最开始左侧为$\frac{0}{1}$，右侧为$\frac{1}{0}$

之后向序列中每对相邻的分数$\frac{p_1}{q_1}$与$\frac{p_2}{q_2}$之间插入$\frac{p_1+p_2}{q_1+q_2}$

以$\frac{1}{1}$为根，将除了$\frac{0}{1}$与$\frac{1}{0}$之外的所有分数向生成它的两个分数之中最深的那一个连边即可获得Stern-Brocott树。这里的深是指迭代法雷序列的迭代深度。

若在每次迭代中将所有分母大于当前迭代次数的分数都去掉，则每层新产生的分数为所有分母为当前迭代层数的真分数。

```cpp
pair<ll, ll> get_frac(dbl x, ll p1, ll q1, ll p2, ll q2) {
    ll p3 = (p1 + p2), q3 = (q1 + q2), d = gcd(p3, q3);
    p3 /= d; q3 /= d;
    if (fabs(q3 * x - p3) < eps) return { p3, q3 };
    else if (x * q3 < p3) return get_frac(x, p1, q1, p3, q3);
    else return get_frac(x, p3, q3, p2, q2);
}
```

### 单峰函数求极值（三分）

```cpp

typedef double dbl;
const dbl eps = 1e-8, phi = (sqrt(5) - 1) / 2;
pair<dbl, dbl> gss0(const function<dbl(dbl)>& f,
         dbl l1, dbl l2, dbl r2, dbl r1,
         dbl l1v, dbl l2v, dbl r2v, dbl r1v) {
    if (l2 + eps >= r2) {
        if (l2v < r2v) return { l2, l2v };
        else return { r2, r2v };
    }
    if (l2v > r2v)  //  < for minimum, > for maximum
        return gss0(f, l1, r2 - phi * (r2 - l1), l2, r2,
                    l1v, f(r2 - phi * (r2 - l1)), l2v, r2v);
    else
        return gss0(f, l2, r2, l2 + phi * (r1 - l2), r1,
                    l2v, r2v, f(l2 + phi * (r1 - l2)), r1v);
}

pair<dbl, dbl> gss(const function<dbl(dbl)>& f,
                   dbl l1, dbl r1) {
    dbl t = phi * (r1 - l1), l2 = r1 - t, r2 = l1 + t;
    return gss0(f, l1, l2, r2, r1, f(l1), f(l2), f(r2), f(r1));
}

//Example:
//Gym101981D(2018南京现场赛D) 最小球覆盖，三分套三分套三分，nlogM^3
//这里的M是1e5/1e-8=1e13，至少有个1.5倍的常数，因为log的底数是phi+1
int main() {
    cout << fixed << setprecision(10) << gss([&](dbl x) {
            return gss([&](dbl y) {
                return gss([&](dbl z) {
                    dbl res = 0;
                    for (vec w : v)
                        res = max(res, dis(w, {x,y,z}));
                    return res;
                }, -1e5, 1e5).second;
            }, -1e5, 1e5).second;
        }, -1e5, 1e5).second <<endl;
    }
```

### 自适应辛普森积分

```cpp

template<class F> dbl sps0(const F& f,dbl l, dbl r) {
    return (f(l) + 4 * f((l + r) / 2) + f(r)) * (r - l) / 6;
}

template<class F> dbl sps1(const F& f, dbl l, dbl r, dbl eps, dbl s) {
    dbl m = (l + r) / 2, lv = sps0(f, l, m), rv = sps0(f, m, r), d = lv + rv - s;
    if (fabs(d) < 15 * eps) return lv + rv + 15 * d;
    else return sps1(f, l, m, eps / 2, lv) + sps1(f, m, r, eps / 2, rv);
}

template<class F> dbl spsint(const F& f, dbl l, dbl r, dbl eps) {
    return sps1(f, l, r, eps, sps0(f, l, r));
}

```

### 三次/四次方程求复根

```cpp

#define sq(x) ((x) * (x))

#define cb(x) (sq(x) * (x))

typedef complex<dbl> cplx;
void cubic(dbl a0, dbl a1, dbl a2, dbl a3,
    cplx& x1, cplx& x2, cplx& x3) {
    a0 /= a3; a1 /= a3; a2 /= a3;
    dbl p = sq(a2) / 9 - a1 / 3, q = a2 * a1 / 6 - cb(a2) / 27 - a0/ 2;
    cplx del = sqrt((cplx)(sq(q) - cb(p))), w(-0.5, sqrt(3) / 2),
        f1 = pow(q + del, 1. / 3), f2 = pow(q - del, 1. / 3);
    x1 = f1 + f2 - a2 / 3;
    x2 = w * f1 + sq(w) * f2 - a2 / 3;
    x3 = sq(w) * f1 + w * f2 - a2 / 3;
}

void quadr(dbl a0, dbl a1, dbl a2, dbl a3, dbl a4,
    cplx& x1, cplx& x2, cplx& x3, cplx& x4) {
    a0 /= a4; a1 /= a4; a2 /= a4; a3 /= a4; a3 /= 4;
    dbl b = a2 - 6 * sq(a3), c = 3 * (a1 - 2 * a2 * a3 + cb(2 * a3)),
        d = 12 * (a0 - a1 * a3 + a2 * sq(a3) - 3 * sq(sq(a3))),
        p = sq(b) + d, q = 2 * cb(b) + 3 * sq(c) - 6 * b * d, k = 2 * sqrt(3);
    cplx del = sqrt((cplx(sq(q) - 4 * cb(p)))),
        f = pow((q + del) / 2., 1. / 3) + pow((q - del) / 2., 1. / 3),
        f1 = sqrt(f - 2 * b), f2 = k * c / f1, f3 = -4 * b - f;
    x1 = (f1 - sqrt(f3 - f2)) / k - a3; x2 = (f1 + sqrt(f3 - f2)) / k - a3;
    x3 = (-f1 - sqrt(f3 + f2)) / k - a3; x4 = (-f1 + sqrt(f3 + f2)) / k - a3;
}

```

### 多项式方程求实根

```cpp

const dbl eps = 1e-8;
int sgn(dbl d) { return d < -eps ? -1 : d > eps ? 1 : 0; }

dbl val(const vector<dbl>& p, dbl x) {
    dbl w = 1, r = 0;
    for(int i = 0; i != p.size(); ++i, w *= x)
        r += p[i] * w;
    return r;
}

dbl fr(const vector<dbl>& p, dbl lb, dbl ub, bool flg) {
    dbl x = (lb + ub) / 2;
    while(sgn(ub - lb)) {
        dbl res = val(p, x);
        if (!sgn(res)) break;
        else if (flg ^ (sgn(res) == 1)) lb = x;
        else ub = x; x = (ub + lb) / 2;
    }
    return x;
}

vector<dbl> peq(vector<dbl> p) {
    if (p.size() < 2) return {};
    else if (p.size() == 2) return { -p[0] / p[1] };
    else {
        vector<dbl> p_, res, sx, sy; dbl b = 0;
        for (int i = 0; i != p.size(); ++i) b = max(b, abs(p[i] / p[0]) + 1);
        for (int i = 1; i != p.size(); ++i) p_.push_back(p[i] * i);
        sx = peq(p_); sx.insert(sx.begin(), -b); sx.push_back(b);
        for (dbl x : sx) sy.push_back(val(p, x));
        for (int i = 0; i != sx.size() - 1; ++i)
            if (sgn(sy[i] * sy[i + 1]) == -1)
                res.push_back(fr(p, sx[i], sx[i + 1], sgn(sy[i]) == -1));
        return res;
    }
}

```

## 多项式

### 初等对称多项式

对于变量集$X=\{x_1, x_2, ... , x_m\}$，其上的$n$阶初等对称多项式$\sigma_n$被定义为

$$\sigma_n= \sum_{|S|=n,S\subseteq X}{\prod_{x_i \in S}x_i}$$

特别的，恒有$\sigma_0=1$。

即

$$\sigma_1=x_1+x_2+...+x_n$$

$$\sigma_2=x_1x_2+x_1x_3+...+x_{n-1}x_n$$

$$...$$

$$\sigma_{m}=x_1x_2...x_m$$

向$X$中加入元素$x'$后对$\sigma_k$的影响：

$$\sigma_1'=\sigma_1+x'=\sigma_1+\sigma_0x'$$

$$\sigma_2'=\sigma_2+x_1x'+x_2x'+...+x_mx'=\sigma_2+\sigma_1x'$$

$$...$$

$$\sigma_k'=\sigma_k+\sigma_{k-1}x'$$

从$X$中删去元素$x'$后对$\sigma_k$的影响：

$$\sigma_1'=\sigma_1-\sigma_0'x'$$

$$\sigma_2'=\sigma_2-\sigma_1'x'$$

$$...$$

$$\sigma_k'=\sigma_k-\sigma_{k-1}'x'$$

由定义易得对称多项式的OGF：

$$F(x)=\prod_{x_i \in X}(1+x_ix)$$

若设

$$s_n=\sum_{x \in X}{x^n}$$

则存在恒等式（牛顿公式）：

$$\sigma_k=\frac{(-1)^{k-1}}{k}\sum_{i=0}^{k-1}{(-1)^i\sigma_is_{k-i}}$$

## 快速变换与卷积

### FFT

```cpp

typedef double dbl;
typedef complex<dbl> cplx;
const dbl pi = acos(-1);

int fr[N], fs;
void init(int s) {
    for (fs = 1; fs <= s; fs <<= 1);
    for (int i = 0; i != fs; ++i)
        fr[i] = (fr[i >> 1] >> 1) | (i & 1 ? (fs >> 1) : 0);
}

void fft(cplx* p, int f) {
    for (int i = 0; i != fs; ++i) if (i < fr[i]) swap(p[i], p[fr[i]]);
    for (int i = 1; i != fs; i <<= 1) {
        cplx w0{ cos(pi / i), f * sin(pi / i) };
        for (int j = 0; j != fs; j += (i << 1)) {
            cplx w{ 1, 0 };
            for (int k = 0; k != i; k++) {
                cplx u = p[j + k], v = w * p[i + j + k];
                p[j + k] = u + v; p[i + j + k] = u - v;
                w *= w0;
            }
        }
    }
}

void fft_res(cplx* p) {
    for (int i = 0; i != fs; ++i)
        p[i] = p[i] * (1. / fs);
}

cplx p1[N], p2[N], p3[N];
int conv(int* a, int n, int* b, int m, int* c) {
    init(n + m + 1);
    for (int i = 0; i <= n; ++i) p1[i] = a[i];
    fill(p1 + n + 1, p1 + fs, cplx{});
    for (int i = 0; i <= m; ++i) p2[i] = b[i];
    fill(p2 + m + 1, p2 + fs, cplx{});
    fft(p1, 1); fft(p2, 1);
    for (int i = 0; i != fs; ++i) p3[i] = p1[i] * p2[i];
    fft(p3, -1); fft_res(p3);
    for (int i = 0; i != fs; ++i) c[i] = round(p3[i].real());
    return fs;
}
```

### NTT

### FWT

$$h(U)=\sum_{S \circ T=U}f(S)g(T)$$

FWT|&|\||^||IFWT|&|\||^
-|-|-|-|-|-|-|-|-
`a[i+j]=`|`x+y`|`x`|`x+y`||`a[i+j]=`|`x-y`|`x`|`(x+y)/2`
`a[i+j+k]=`|`y`|`x+y`|`x-y`||`a[i+j+k]=`|`y`|`y-x`|`(x-y)/2`

```cpp

void fwt(ll* a, int n) {
    for (int k = 1; k < n; k <<= 1)
        for (int m = k << 1, i = 0; i < n; i += m)
            for (int j = 0; j != k; j++) {
                ll x = a[i + j], y = a[i + j + k];
                //a[i + j] = ...
                //a[i + j + k] = ...
            }
}
```

### FZT/FMT

FZT($\zeta$变换):$$g(S)=\sum_{T \subseteq S}f(T)$$

FMT($\mu$变换): $$g(S)=\sum_{T \subseteq S}{(-1)^{|S|-|T|}f(T)}$$

```cpp

void fzt(ll* f, ll* g, int w) {
    copy_n(f, 1 << w, g);
    for (int i = 0; i != w; ++i)
        for (int j = 0; j != (1 << w); ++j)
            if (j & (1 << i)) g[j] += f[s ^ (1 << i)];
}

void fmt(ll* f, ll* g, int w) {
    copy_n(f, 1 << w, g);
    for (int i = 0; i != w; ++i)
        for (int j = 0; j != (1 << w); ++j)
            if (j & (1 << i)) g[j] -= f[s ^ (1 << i)];
}
```
