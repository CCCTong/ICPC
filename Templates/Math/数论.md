# 数论

## 基本函数

### 欧拉筛

|||(1)|(2)|(3)|(4)|
|-|-|-|-|-|-|
|最小质因子幂次|pk[i]|0|1|1|pk[i]+1|
|最小质因子的幂|px[i]|1|i|p|px[i]*p|
|莫比乌斯$\mu$函数|mu[i]|1|-1|-mu[i]|0|
|欧拉$\varphi$函数|ph[i]|1|i-1|ph[i]\*(j-1)|ph[i]\*j|
|除数函数$d(i)$|dc[i]|1|2|dc[i]*2|dc[i]+dc[i]/(pk[i]+1)|
|除数和函数$\sigma(i)$|ds[i]|1|i+1|ds[i]\*(p+1)|ds[i/px[i]]\*((px[i]\*p\*p)-1)/(p-1)|

```

//	DivisorCount dc[i];
//	(1): 2;		(2): dc[i] * 2;
//	(3): dc[i] / (pk[i] + 1) * (pk[i] + 2);
//	(3): dc[i] + dc[i] / (pk[i] + 1);

//	DivisorSum ds[i];
//	(1): i + 1;	(2): ds[i] * (p + 1);
//	(3): ds[i / px[i]] * (qpow(p, pk[i] + 2) - 1) / (p - 1)
//	(3): ds[i / px[i]] * ((px[i] * p * p) - 1) / (p - 1)

//	Sum of coprime numbers; sigma[i] = i * ph[i] / 2;
#define W 1000001
bool ip[W]; vector<ll> ps;
void eulersieve() {
    ps.reserve(N * 1.2 / log(N));
    memset(ip, 1, sizeof(ip)); ip[1] = 0;
    // f[1] = (1)
    for (int i = 2; i != N; ++i) {
        if (ip[i]) {
            ps.push_back(i);
            // f[i] = (2)
        }
        for (ll j : ps) {
            if (i * j >= N) break;
            ip[i * j] = 0;
            if (i % j) {
                // f[i * j] = (3)
            }
            else {
                // f[i * j] = (4)
                break;
            }
        }
    }
}

```

## 顶和底

$$\left\lceil\frac{a}{b}\right\rceil=\left\lfloor\frac{a-1}{b}\right\rfloor+1$$

$$\left\lfloor\frac{a}{b}\right\rfloor=\left\lceil\frac{a+1}{b}\right\rceil-1$$

$$a \leq \left\lfloor\frac{b}{c}\right\rfloor \Leftrightarrow ac \leq b$$

$$a \lt \left\lfloor\frac{b}{c}\right\rfloor \Leftrightarrow ac \lt b$$

$$a \geq \left\lceil\frac{b}{c}\right\rceil\Leftrightarrow ac \geq b$$

$$a \gt \left\lceil\frac{b}{c}\right\rceil\Leftrightarrow ac \gt b$$

```
ll ceil(ll b, ll a) { return b / a + (b % a != 0 && sgn(a) * sgn(b) > 0); }
ll floor(ll b, ll a) { return b / a - (b % a != 0 && sgn(a) * sgn(b) < 0); }
```

### 类欧几里得 

主要参考https://www.cnblogs.com/zzqsblog/p/8904010.html

$$f(k_1,k_2,a,b,c,n)=\sum_{x=0}^n{x^{k_1}\left\lfloor \frac{ax+b}{c}\right\rfloor^{k_2}}$$

若$a \geq c$或$b \geq c$，令$a=q_ac+r_a,b=q_bc+r_b$

$$f(k_1,k_2,a,b,c,n)=\sum_{x=0}^n{x^{k_1}\left(\left\lfloor\frac{r_ax+r_b}{c}\right\rfloor+q_ax+q_b\right)^{k_2}}$$

$$=\sum_{i=0}^{k_2}{\binom{k_2}{i}\sum_{x=0}^{n}{x^{k_1}\left\lfloor\frac{r_ax+r_b}{c}\right\rfloor^{k_2-i}}(q_ax+q_b)^{i}}$$

$$=\sum_{i=0}^{k_2}{\binom{k_2}{i}\sum_{j=0}^{i}{\binom {i}{j}q_a^{j}q_b^{i-j}\sum_{x=0}^{n}{x^{k_1+j}\left\lfloor\frac{r_ax+r_b}{c}\right\rfloor^{k_2-i}}}}$$

$$=\sum_{i=0}^{k_2}{\binom{k_2}{i}\sum_{j=0}^{i}{\binom {i}{j}q_a^{j}q_b^{i-j}f(k_1+j,k_2-i,r_a,r_b,c,n)}}$$

若$a=0$

$$f(k_1,k_2,a,b,c,n)=\sum_{x=0}^n{x^{k_1}{\left\lfloor\frac{b}{c}\right\rfloor}^{k_2}}=\left\lfloor\frac{b}{c}\right\rfloor^{k_2}\sum_{x=0}^n{x^{k_1}}$$

若$k_2=0$

$$f(k_1,k_2,a,b,c,n)=\sum_{x=0}^n{x^{k_1}}$$

若$an+b\leq c$

$$f(k_1,k_2,a,b,c,n)=0$$

否则有$a \leq c$且$b \leq c$，进行代换
$$w^{k_2}=\sum_{y=0}^{w-1}{((y+1)^{k_2}-y^{k_2})}$$

$$f(k_1,k_2,a,b,c,n)=\sum_{x=0}^n{x^{k_1}\sum_{y=0}^{\left\lfloor \frac{ax+b}{c}\right\rfloor-1}{((y+1)^{k_2}-y^{k_2})}}$$

## 不定方程

### 勾股数

不定方程$$x^2+y^2=z^2$$的所有正整数解被称为勾股数。

通过枚举$a>b>0,\gcd(a,b)=1,2 \nmid (a+b)$可以获得所有本原勾股数，枚举这些勾股数的所有倍数可以获得所有勾股数。

$$ \left\{
\begin{aligned}
x & = & 2ab \\
y & = & a^2-b^2 \\
z & = & a^2+b^2
\end{aligned}
\right.
$$

```cpp
// Primitive Pythagorean Triple
void get() {
    ll sum = 0;
    for (ll b = 1;; ++b) {
        for (ll a = b + 1;; a += 2) {
            if (gcd(a, b) != 1) continue;
            ll x = 2 * a * b;
            ll y = a * a - b * b;
            ll z = a * a + b * b;
            //cout << x << ' ' << y << ' ' << z << endl;
        }
    }
}
```

### 佩尔方程

佩尔方程是形如

$$x^2-dy^2=1$$

的二次不定方程。

若$d<-1$则只有$$

```cpp

bool pell_roots(ll d, ll& x, ll& y) {
    static ll a[20000];
    double s = sqrt(d); ll m = s;
    if (m * m == d) return false;
    ll l = 0, b = m, c = 1; a[l++] = m;
    do {
        c = (d - b * b) / c;
        a[l++] = floor((s + b) / c);
        b = a[l - 1] * c - b;
    } while (a[l - 1] != 2 * a[0]);
    ll p = 1, q = 0;
    for (int i = l - 2; i >= 0; --i)
        swap(p, q), p += q * a[i];
    if (l % 2) x = p, y = q;
    else x = 2 * p * p + 1, y = 2 * p * q;
    return true;
}

```


## 杂项

### 完全数

偶完全数据有形式$2^{n-1}(2^n-1)$，目前未发现奇完全数。
