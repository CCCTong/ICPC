# 数论

## 积性函数与筛法

### 积性函数

函数$f(x)$是积性函数当且仅当$\forall a, b, \gcd(a,b)=1,f(a)f(b)=f(ab)$。

常见的积性函数：

$e$: $e(n)=[n==1]$

$1$: $1(n)=1$

$id$: $id(n)=n$

$\varphi$: $\varphi(i)=$

### 狄利克雷卷积

两个函数的狄利克雷卷积为

$$(f*g)(n)=\sum_{d|n}{f(d)g(\frac nd)}$$

常见积性函数的卷积关系：

$id=\varphi * 1$

$e=\mu * 1$

$d = 1 * 1$

$\sigma=id * 1$

$\varphi = id * \mu$

### 欧拉筛

|||(1)|(2)|(3)|(4)|
|-|-|-|-|-|-|
|最小质因子幂次|pk[i]|0|1|1|pk[i]+1|
|最小质因子的幂|px[i]|1|i|p|px[i]*p|
|莫比乌斯$\mu$函数|mu[i]|1|-1|-mu[i]|0|
|欧拉$\varphi$函数|ph[i]|1|i-1|ph[i]\*(j-1)|ph[i]\*j|
|除数函数$d(i)$|dc[i]|1|2|dc[i]*2|dc[i]+dc[i]/(pk[i]+1)|
|除数和函数$\sigma(i)$|ds[i]|1|i+1|ds[i]\*(p+1)|ds[i/px[i]]\*((px[i]\*p\*p)-1)/(p-1)|
|$\sum_{i=1}^{n}{i[gcd(i,n)=1]}$|sigma[i]|i * ph[i] / 2|

```cpp
#define W 1000001
bool ip[W]; vector<ll> ps;
void eulersieve() {
    ps.reserve(N * 1.2 / log(N));
    memset(ip, 1, sizeof(ip)); ip[1] = 0;
    // f[1] = (1)
    for (int i = 2; i != N; ++i) {
        if (ip[i]) {
            ps.push_back(i);
            // f[i] = (2)
        }
        for (ll j : ps) {
            if (i * j >= N) break;
            ip[i * j] = 0;
            if (i % j) {
                // f[i * j] = (3)
            }
            else {
                // f[i * j] = (4)
                break;
            }
        }
    }
}

```

### 杜教筛

目的：求积性函数$f(x)$的前缀和$S_f(n)=\sum_{i=1}^{n}{f(i)}$。

若存在积性函数$g,h$满足$f *g=h$，且$S_g$与$S_h$能快速求出，则$S_f(n)$能在$O(n^{\frac{2}{3}})$内求出。

推导：

$$S_h(n)=\sum_{i=1}^{n}{h(i)}=\sum_{i=1}^{n}{\sum_{d|i}{g(d)f(\frac{i}{d})}}=\sum_{d=1}^{n}{g(d)\sum_{d|i \wedge i \leq n}{f(\frac id)}}=\sum_{d=1}^n{g(d)\sum_{j=1}^{\left\lfloor\frac nd \right \rfloor}f(j)}=\sum_{d=1}^n{g(d)S_f(\left\lfloor\frac nd \right \rfloor)}$$

右式可数论分块，用线性筛法处理出前$n^{\frac{2}{3}}$个$S_f(n)$可将复杂度降至$O(n^{\frac{2}{3}})$。

常见的$f$与$g$和$h$。

|f|g|h|推导|
|-|-|-|-|
|$i^k\varphi(i)$|$id^k$|$id^{k+1}$|$$\sum_{d \mid n}{d^k \left(\frac nd\right)^k\varphi(\frac nd)}=n^k\sum_{d \mid n}{\varphi (\frac n d)}=n^{k+1}$$|
|$i^k\mu(i)$|$id^k$|$e$|$$\sum_{d \mid n}{d^k \left(\frac nd\right)^k\mu(\frac nd)}=n^k\sum_{d \mid n}{\mu(\frac n d)}=n^k[n=1]=e$$|
|$\varphi * \mu$|$1$|$\varphi$|$(\varphi * \mu) * 1=\varphi * (\mu * 1) = \varphi * e = \varphi$|

### min25筛

目的：求积性函数$f(x)$的前缀和$S_f(n)=\sum_{i=1}^{n}{f(i)}$。

若$f(p)$可以表达为关于$p$的简单多项式且$f(p^e)$可以快速求，则可以在$O(\frac{n^{\frac 34}}{\log n})$内求出$S_f(n)$。

定义：

1. $p_i$表示第$i$个质数。
2. $m_i$表示$i$的最小质因子。
3. $e_i$表示$i$的最小质因子在$i$中的幂次。

共分两步，求出$g_k(n)=\sum_{p_i \leq n}{p_i^k}$，再用$g_k(n)$求出$S_f(n)$。

#### 第一步：求出$g_k(n)$

观察到$i^k$是完全积性函数，考虑利用完全积性筛出$g_k(n)$，即一步步把最小质因子为某个质数的数的$k$次方筛掉。

定义$g_k(n,j)$表示筛掉了最小质因子小于等于$p_j$的所有$i^k$后余下所有$i^k$的和（只筛合数不筛质数）。也可写作
$$g_k(n,j)=\sum_{i=1}^{j}{p_i^k}+\sum_{m_i \gt p_j}{i^k}$$

我们要求的$g_k(n)=g_k(n,\infty)$。经过简单推导可以得到：

$$ g_k(n,j)=\left\{
\begin{array}{lcl}
g(n,j-1) & & {p_j > \sqrt{n}} \\
g(n,j-1)-p_j^k\left(g(\lfloor\frac{n}{p_j}\rfloor,j-1)-g(p_j-1,j-1)\right)& & {p_j \leq \sqrt{n}}\\
\sum_{i=1}^{n}{i^k}& &j=0
\end{array}
\right.
$$

注：第$j$步筛掉的是所有最小质因子为$p_j$的合数的$k$次方之和。在第$j-1$步的基础上，所有$n$以内的最小质因子为$p_j$的合数在除以$p_j$后余下部分的$k$次方之和即为$g(\lfloor\frac{n}{p_j}\rfloor,j-1)$减去未被筛去的小于$p_j$的质数的$k$次方之和。

#### 第二步：求出$S_f(n)$

这一步需要将$f(n)$在第一步中筛去的在合数位置的取值按相反的顺序加回来。

定义$S(n,j)$为将最小质因子小于等于$p_j$的合数位置上的取值筛去后的$S_f(n)$，即

$$S(n,j)=\sum_{i=1}^{j}f(p_i)+\sum_{m_i \gt p_j}{f(i)}$$

按相反的顺序，加入最小质因子为$p_j$的所有合数位置上的取值，为此需要枚举$p_j$的幂次$e$。

$$S(n,j-1)=S(n,j)+\sum_{e=1}{f(p_j^e)\left(S(\lfloor\frac{n}{p_j^e}\rfloor,j)-g()\right)}$$

## 顶和底

|顶|底|
|-|-|
|$\left\lceil\frac{a}{b}\right\rceil=\left\lfloor\frac{a-1}{b}\right\rfloor+1$|$\left\lfloor\frac{a}{b}\right\rfloor=\left\lceil\frac{a+1}{b}\right\rceil-1$|
|$a \geq \left\lceil\frac{b}{c}\right\rceil\Leftrightarrow ac \geq b$|$a \leq \left\lfloor\frac{b}{c}\right\rfloor \Leftrightarrow ac \leq b$
|$a \gt \left\lceil\frac{b}{c}\right\rceil\Leftrightarrow ac \gt b$|$a \lt \left\lfloor\frac{b}{c}\right\rfloor \Leftrightarrow ac \lt b$|

```cpp
ll ceil(ll b, ll a) { return b / a + (b % a != 0 && sgn(a) * sgn(b) > 0); }
ll floor(ll b, ll a) { return b / a - (b % a != 0 && sgn(a) * sgn(b) < 0); }
```

### 类欧几里得 

主要参考https://www.cnblogs.com/zzqsblog/p/8904010.html

$$f(k_1,k_2,a,b,c,n)=\sum_{x=0}^n{x^{k_1}\left\lfloor \frac{ax+b}{c}\right\rfloor^{k_2}}$$

若$a \geq c$或$b \geq c$，令$a=q_ac+r_a,b=q_bc+r_b$

$$f(k_1,k_2,a,b,c,n)=\sum_{x=0}^n{x^{k_1}\left(\left\lfloor\frac{r_ax+r_b}{c}\right\rfloor+q_ax+q_b\right)^{k_2}}$$

$$=\sum_{i=0}^{k_2}{\binom{k_2}{i}\sum_{x=0}^{n}{x^{k_1}\left\lfloor\frac{r_ax+r_b}{c}\right\rfloor^{k_2-i}}(q_ax+q_b)^{i}}$$

$$=\sum_{i=0}^{k_2}{\binom{k_2}{i}\sum_{j=0}^{i}{\binom {i}{j}q_a^{j}q_b^{i-j}\sum_{x=0}^{n}{x^{k_1+j}\left\lfloor\frac{r_ax+r_b}{c}\right\rfloor^{k_2-i}}}}$$

$$=\sum_{i=0}^{k_2}{\binom{k_2}{i}\sum_{j=0}^{i}{\binom {i}{j}q_a^{j}q_b^{i-j}f(k_1+j,k_2-i,r_a,r_b,c,n)}}$$

若$a=0$

$$f(k_1,k_2,a,b,c,n)=\sum_{x=0}^n{x^{k_1}{\left\lfloor\frac{b}{c}\right\rfloor}^{k_2}}=\left\lfloor\frac{b}{c}\right\rfloor^{k_2}\sum_{x=0}^n{x^{k_1}}$$

若$k_2=0$

$$f(k_1,k_2,a,b,c,n)=\sum_{x=0}^n{x^{k_1}}$$

若$an+b\leq c$

$$f(k_1,k_2,a,b,c,n)=0$$

否则有$a \leq c$且$b \leq c$，进行代换
$$w^{k_2}=\sum_{y=0}^{w-1}{((y+1)^{k_2}-y^{k_2})}$$

$$f(k_1,k_2,a,b,c,n)=\sum_{x=0}^n{x^{k_1}\sum_{y=0}^{\left\lfloor \frac{ax+b}{c}\right\rfloor-1}{((y+1)^{k_2}-y^{k_2})}}$$

## 不定方程

### 勾股数

不定方程$$x^2+y^2=z^2$$的所有正整数解被称为勾股数。

通过枚举$a>b>0,\gcd(a,b)=1,2 \nmid (a+b)$可以获得所有本原勾股数，枚举这些勾股数的所有倍数可以获得所有勾股数。

$$ \left\{
\begin{aligned}
x & = & 2ab \\
y & = & a^2-b^2 \\
z & = & a^2+b^2
\end{aligned}
\right.
$$

```cpp
// Primitive Pythagorean Triple
void get() {
    ll sum = 0;
    for (ll b = 1;; ++b) {
        for (ll a = b + 1;; a += 2) {
            if (gcd(a, b) != 1) continue;
            ll x = 2 * a * b;
            ll y = a * a - b * b;
            ll z = a * a + b * b;
            //cout << x << ' ' << y << ' ' << z << endl;
        }
    }
}
```

### 佩尔方程

佩尔方程是形如

$$x^2-dy^2=1$$

的二次不定方程。

若$d<-1$则只有$$

```cpp

bool pell_roots(ll d, ll& x, ll& y) {
    static ll a[20000];
    double s = sqrt(d); ll m = s;
    if (m * m == d) return false;
    ll l = 0, b = m, c = 1; a[l++] = m;
    do {
        c = (d - b * b) / c;
        a[l++] = floor((s + b) / c);
        b = a[l - 1] * c - b;
    } while (a[l - 1] != 2 * a[0]);
    ll p = 1, q = 0;
    for (int i = l - 2; i >= 0; --i)
        swap(p, q), p += q * a[i];
    if (l % 2) x = p, y = q;
    else x = 2 * p * p + 1, y = 2 * p * q;
    return true;
}

```

## 杂项

### 完全数

偶完全数据有形式$2^{n-1}(2^n-1)$，目前未发现奇完全数。

### 反素数

```cpp

//  求在因子数最多的前提下最小的数x
pair<ll, ll> dfs(ll n, int c, int i, ll a, ll b) {
    if (i == 12) return { -a, b };
    else {
        int p = ps[i]; ll q = 1;
        pair<ll, ll> res = { 0, 0 };
        for (int e = 0; e <= c && n / q; ++e, q *= p)
            res = min(res, dfs(n / q, e, i + 1, a * (e + 1), b * q));
        return res;
    }
}

//  Usage:
//  pair<ll, ll> res = dfs(n, 114514, 0, 1, 1);
//  -res.first: d(x)
//  res.second: x

```

#### $10^n$以内因子最多的数

|n=|x=|d(x)|
|--|--|----|
|1|6|4|
|2|60|12|
|3|840|32|
|4|7560|64|
|5|83160|128|
|6|720720|240|
|7|8648640|448|
|8|73513440|768|
|9|735134400|1344|
|10|6983776800|2304|
|11|97772875200|4032|
|12|963761198400|6720|
|13|9316358251200|10752|
|14|97821761637600|17280|
|15|866421317361600|26880|
|16|8086598962041600|41472|
|17|74801040398884800|64512|
|18|897612484786617600|103680|

## 常见推导

### 展开$[gcd(i,n)=1]$

$$\sum_{i=1}^m{i^k[gcd(i,n)=1]}=\sum_{i=1}^m{i^k\sum_{d|i \wedge d|n}{\mu(d)}}=\sum_{d|n}{\mu(d)\sum_{d|i \wedge i \leq m}{i^k}}=\sum_{d|n}{\mu(d)\sum_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}{(dj)^k}}=\sum_{d|n}{\mu(d)d^k\sum_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}{j^k}}$$
